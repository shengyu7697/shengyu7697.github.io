<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShengYu Talk</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shengyu7697.github.io/"/>
  <updated>2024-09-25T14:40:08.031Z</updated>
  <id>https://shengyu7697.github.io/</id>
  
  <author>
    <name>ShengYu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>軟體開發常見陷阱：過早優化 Premature Optimization</title>
    <link href="https://shengyu7697.github.io/premature-optimization/"/>
    <id>https://shengyu7697.github.io/premature-optimization/</id>
    <published>2024-09-19T12:00:00.000Z</published>
    <updated>2024-09-25T14:40:08.031Z</updated>
    
    <content type="html"><![CDATA[<p>在軟體開發中，過早優化（Premature Optimization）是一個常見陷阱。這個陷阱常常發生在專案的早期階段，開發者過度關注細節或效能問題，試圖讓程式碼跑得更快或佔用更少資源，結果反而忽視了核心功能與可維護性。</p><h2><span id="什麼是過早優化">什麼是過早優化？</span></h2><p>就是你還沒確認程式的效能真的出現瓶頸，卻急著去優化某些部分。就好像你剛開始學跑步，還沒跑多遠就去研究如何減少鞋底跟地面的摩擦力。優化可能會帶來一點點效能提升，但問題是你不知道有沒有真的需要這樣的優化！</p><h2><span id="為什麼這是個陷阱">為什麼這是個陷阱？</span></h2><ol><li><p>浪費時間<br>我想大家都很同意時間是寶貴的，你在早期花了大量時間去調整那些不會產生明顯效能差異的細節，把時間都花在微調上，核心功能卻可能還沒做好。以為自己是個高效率開發者，實際上是在繞遠路。最終拖慢開發速度，浪費大量時間在不重要的細節上，卻無法快速交付可用的功能。</p></li><li><p>程式碼變複雜<br>為了達到極致效能，你可能會寫出一些讓人無法理解的程式碼。結果是什麼？日後維護時你自己或其他開發者可能會花上雙倍的時間去解讀這段程式碼。效能提升了，但維護成本也隨之上升。</p></li><li><p>預測錯誤問題/提前處理假設問題<br>有些開發者喜歡預防性優化，可能會預測未來可能的效能瓶頸，並提前優化這些假設問題。結果這些瓶頸有可能永遠不會出現，反而因為其他需求變動，這些預防性優化變得毫無意義。</p></li></ol><h2><span id="如何避免過度優化">如何避免過度優化？</span></h2><p>1.「先讓它跑起來，再讓它跑得快」的原則<br>就是先求有再求好，先專注於實現核心功能，正確性比速度重要，先確保程式能夠正確執行。當系統穩定且功能完善後，如果效能真的成為問題，再進行效能優化。</p><ol><li><p>使用效能分析工具<br>在需要優化時，使用效能分析工具找出真正的瓶頸，與其憑感覺優化，不如用工具來幫你找出真正的瓶頸。避免浪費時間在不重要的部分，做最有效的優化。</p></li><li><p>需求導向的優化<br>只有在確認系統效能不足以應對實際需求時，才需要進行優化。這樣能避免無謂的過早優化。不要因為「效能強迫症」讓自己陷入無謂的工作。</p></li></ol><p>總結一下，過早優化是很多開發者在成長過程中都會經歷的階段，這很正常。我們追求更好的效能能、寫出更完美的程式碼，但不要忘了，真正的目標是「解決問題」，而不是在不必要的地方過度用力。與其執著於微小的效能提升，不如專注於讓產品真正執行、幫助使用者！等到真正需要優化時再考慮效能提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在軟體開發中，過早優化（Premature Optimization）是一個常見陷阱。這個陷阱常常發生在專案的早期階段，開發者過度關注細節或效能問題，試圖讓程式碼跑得更快或佔用更少資源，結果反而忽視了核心功能與可維護性。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;什麼是過早優化&quot;
      
    
    </summary>
    
      <category term="軟體開發" scheme="https://shengyu7697.github.io/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="軟體開發" scheme="https://shengyu7697.github.io/tags/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>設計原則 - 依賴反轉原則 Dependency Inversion Principle</title>
    <link href="https://shengyu7697.github.io/dependency-inversion-principle/"/>
    <id>https://shengyu7697.github.io/dependency-inversion-principle/</id>
    <published>2024-09-18T12:00:00.000Z</published>
    <updated>2024-09-19T13:40:07.101Z</updated>
    
    <content type="html"><![CDATA[<p>在軟體設計中，我們經常面對類別之間的依賴關係。想像你正在開發一個龐大的系統，當中某個小功能需要變更，卻發現一改動就要牽扯到許多不相關的部分。這種情況下你是不是會開始懷疑，設計是否有問題？  </p><p>這就是設計原則出現的原因，特別是「依賴反轉原則 (Dependency Inversion Principle, DIP)」，它能幫助我們建立靈活的系統，避免高耦合的噩夢。  </p><h2><span id="什麼是依賴反轉原則">什麼是依賴反轉原則？</span></h2><p>依賴反轉原則是一種解決依賴問題的設計原則，依賴反轉原則強調：<strong>高層模組不應依賴於低層模組，兩者都應依賴於抽象</strong>。這聽起來可能有點抽象，但換句話說，就是我們要將具體的細節抽象化，讓不同層級的模組之間解耦不直接依賴彼此的實作，進而減少維護成本與錯誤的機會。  </p><p>依賴反轉原則主要包含兩個重點：  </p><ol><li>高層模組不應該依賴於低層模組。  </li><li>兩者應該依賴於抽象（介面或抽象類別）。  </li></ol><p>用最白話的方式來理解，就是「大腦不應該直接控制肌肉運動，而是應該透過神經傳導」。同樣道理，應用程式的高層邏輯不應該直接依賴底層細節，而是應該透過一層抽象來進行溝通。  </p><h2><span id="依賴反轉原則的例子">依賴反轉原則的例子</span></h2><p>我們先來看一個不遵守依賴反轉原則的例子。  </p><h3><span id="錯誤的設計違反依賴反轉原則">錯誤的設計，違反依賴反轉原則</span></h3><p>想像你正在設計一個點餐系統，在原始設計裡你可能會這樣實作：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 信用卡付款邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">    CreditCard creditCard;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        creditCard.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這個程式看起來沒什麼問題，但如果突然要新增其他付款方式，例如 PayPal 呢？每當系統需要支援新的付款方式時，你都得改 <code>Order</code> class 類別，這樣的設計很容易隨著功能擴充而變得脆弱。  </p><p>在上面的範例中，<code>Order</code> 類別直接依賴於 <code>CreditCard</code> 類別，這就是違反依賴反轉原則的設計。這樣一來，只要 <code>CreditCard</code> 類別有變動，或者你要加入其他付款方式，<code>Order</code> 的實作就需要大幅改動，這導致系統的維護變得更加困難，擴充性也大打折扣。  </p><h3><span id="正確的設計遵守依賴反轉原則">正確的設計，遵守依賴反轉原則</span></h3><p>我們可以透過抽象的方式解決這個問題。這裡的解決方案就是將付款方式抽象出來，讓 <code>Order</code> 類別不再直接依賴於具體的 <code>CreditCard</code>，而是依賴於一個抽象的付款介面：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentMethod</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> :</span> <span class="keyword">public</span> PaymentMethod &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 信用卡付款邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PayPal</span> :</span> <span class="keyword">public</span> PaymentMethod &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// PayPal付款邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">    PaymentMethod&amp; paymentMethod;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Order(PaymentMethod&amp; method) : paymentMethod(method) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        paymentMethod.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這個範例中，<code>Order</code> 類別不再依賴具體的 <code>CreditCard</code> 或 <code>PayPal</code>，而是依賴於 <code>PaymentMethod</code> 這個抽象介面。這樣，如果將來要新增其他付款方式，我們只需要實作新的付款類別（實作 <code>PaymentMethod</code> class），而不必動到 <code>Order</code> 類別。這樣的設計就遵循了依賴反轉原則，達到了靈活且可擴展的目的。  </p><h2><span id="為什麼這麼做">為什麼這麼做？</span></h2><p>當我們遵循依賴反轉原則，會發現系統變得更加彈性，維護性也提高了。具體實作的變動不會影響高層邏輯，這意味著在不改動核心業務邏輯的情況下，我們可以輕鬆替換或擴充底層的具體實作。  </p><p>例如在付款系統中，隨著業務發展，可能會有新的付款方式不斷加入。依賴反轉原則讓我們在不改動核心訂單處理的情況下，直接新增其他付款方式，保持系統的穩定性與靈活性。  </p><p>但這樣做也有一點缺點，就是會讓設計稍微複雜，特別是對於一些小型專案來說，過度抽象反而會增加開發的負擔。但隨著系統成長，這種設計方式能帶來的好處將遠大於初期的設計成本。  </p><h2><span id="實際應用">實際應用</span></h2><p>依賴反轉原則在很多場景中都非常實用，特別是在大型系統或複雜應用中。例如在網路應用中，我們常常會有不同的資料存取方式，如 SQL、NoSQL 或是基於第三方的 API。透過依賴反轉原則，我們可以為高層邏輯設計一個統一的資料存取介面，而實際的資料庫選擇則可以在不同情況下自由切換，而不影響應用層邏輯。  </p><p>這樣的設計原則也可以應用在許多場景，例如日誌系統、通知系統、甚至是硬體裝置的驅動層。每當你需要擴充或替換具體實作，而不想改動核心邏輯時，依賴反轉原則都是你的好幫手。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在軟體設計中，我們經常面對類別之間的依賴關係。想像你正在開發一個龐大的系統，當中某個小功能需要變更，卻發現一改動就要牽扯到許多不相關的部分。這種情況下你是不是會開始懷疑，設計是否有問題？  &lt;/p&gt;
&lt;p&gt;這就是設計原則出現的原因，特別是「依賴反轉原則 (Dependenc
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>設計原則 - 介面隔離原則 Interface Segregation Principle</title>
    <link href="https://shengyu7697.github.io/interface-segregation-principle/"/>
    <id>https://shengyu7697.github.io/interface-segregation-principle/</id>
    <published>2024-09-17T12:00:00.000Z</published>
    <updated>2024-09-22T01:00:06.795Z</updated>
    
    <content type="html"><![CDATA[<p>想像一下，你的程式裡有一個大型介面，每次新增功能都得修改這個介面，這樣不僅讓開發變得複雜，也讓維護變得困難。這就是為什麼我們需要「介面隔離原則 (Interface Segregation Principle, ISP)」。這個原則告訴我們，與其讓程式依賴一個龐大且複雜的介面，不如讓它們只依賴於它們真正需要的介面，這樣可以讓程式碼更加靈活和容易維護。  </p><h2><span id="什麼是介面隔離原則">什麼是介面隔離原則？</span></h2><p>介面隔離原則的核心概念是：<strong>不要強迫一個類別實作它不需要的介面方法</strong>。這意味著我們應該將大的介面拆分為更小、更具針對性的介面，讓類別只依賴它們所需要的功能。  </p><p>想像一下，如果你是一名廚師，而你的工作清單裡除了煮飯，還包含了洗衣、修車等不相關的工作，你肯定會覺得困擾。對於軟體設計來說，大型介面就像這樣的工作清單，讓不必要的依賴進入系統，增加了複雜性。  </p><h2><span id="介面隔離原則的例子">介面隔離原則的例子</span></h2><p>讓我們用一個具體例子來看，什麼樣的設計會違反介面隔離原則。  </p><h3><span id="錯誤的設計違反介面隔離原則">錯誤的設計，違反介面隔離原則</span></h3><p>假設我們有一個 <code>Worker</code> 介面，裡面定義了各種工作相關的功能，包括寫程式、做簡報、煮飯等：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IWorker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">present</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在，如果有一個 <code>Programmer</code> 類別需要實作這個介面，它只需要寫程式，但仍然得實作 <code>cook</code> 和 <code>present</code> 方法，這些它根本不會用到：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> :</span> <span class="keyword">public</span> IWorker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 寫程式的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要，但必須實作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">present</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要，但必須實作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這種設計顯然是違反了 ISP 的，因為 <code>Programmer</code> 類別被強迫實作了它根本不需要的功能。這不僅讓程式碼冗長，還會帶來未來維護的麻煩。  </p><h3><span id="正確的設計遵守介面隔離原則">正確的設計，遵守介面隔離原則</span></h3><p>正確的設計應該將這些功能分離為多個小介面，讓類別只實作它所需要的功能。例如，我們可以這樣做：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProgrammer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICook</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPresenter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">present</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在 <code>Programmer</code> 類別只需要實作 <code>IProgrammer</code> 介面，完全不需要理會與它無關的 <code>cook</code> 和 <code>present</code> 方法：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> :</span> <span class="keyword">public</span> IProgrammer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 寫程式的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這樣的設計遵守了介面隔離原則，讓類別只專注於它該做的事情，減少了不必要的依賴和負擔。  </p><h2><span id="為什麼這麼做">為什麼這麼做？</span></h2><p>遵守 ISP 有很多好處。首先它讓程式碼更加模組化和易於理解。當介面變小、變專注時，開發者可以更容易地了解每個介面的職責，這減少了混亂。  </p><p>這樣的設計讓我們更容易進行修改和擴展。假如未來需要新增功能，只需修改特定的小介面，而不會影響其他不相關的部分。這讓系統更加穩定，減少了修改時引入錯誤的風險。  </p><p>遵守 ISP 讓我們可以避免不必要的依賴。當類別依賴於一個龐大的介面時，即便只使用其中一部分功能，它仍然會受到整個介面的影響。這種依賴會讓程式變得臃腫且難以維護。  </p><p>然而過度拆分介面也可能帶來額外的複雜性。因此，我們在實踐 ISP 時，應該保持平衡，確保每個介面都有明確的職責，而不過度細化。  </p><h2><span id="實際應用">實際應用</span></h2><p>在大型專案中，遵守介面隔離原則是保持程式碼品質和穩定性的關鍵。例如，在開發圖形使用者介面 (GUI) 時，按鈕、下拉選單等 UI 元件可能會有不同的互動方式。將這些行為拆分成小介面，能夠讓每個元件專注於它自己的功能，而不會被不必要的行為所束縛。  </p><p>另一個應用場景是在大型企業軟體開發中，當需要同時面對不同的使用者需求時，我們可以透過小介面來應對不同的需求變化，確保每個功能都能獨立變動，保持靈活性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像一下，你的程式裡有一個大型介面，每次新增功能都得修改這個介面，這樣不僅讓開發變得複雜，也讓維護變得困難。這就是為什麼我們需要「介面隔離原則 (Interface Segregation Principle, ISP)」。這個原則告訴我們，與其讓程式依賴一個龐大且複雜的介
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>設計原則 - 里氏替換原則 Liskov Substitution Principle</title>
    <link href="https://shengyu7697.github.io/liskov-substitution-principle/"/>
    <id>https://shengyu7697.github.io/liskov-substitution-principle/</id>
    <published>2024-09-16T12:00:00.000Z</published>
    <updated>2024-09-19T13:40:07.101Z</updated>
    
    <content type="html"><![CDATA[<p>你是否曾經遇到過這樣的情況：你寫了一個子類別，卻發現當它被應用於父類別的場景時，程式突然出現了問題？這其實是違反了「里氏替換原則 (Liskov Substitution Principle, LSP)」的例子。LSP 是面向物件設計中的一個重要原則，能幫助我們在使用繼承時保持程式的穩定性。  </p><h2><span id="什麼是里氏替換原則">什麼是里氏替換原則？</span></h2><p>簡單來說，里氏替換原則強調：<strong>所有的子類別應該可以替換掉它們的父類別，而不會影響程式的正確性</strong>。也就是說，如果你的程式原本使用的是父類別，那麼它也應該能夠正常使用任何一個子類別而不會出錯。  </p><p>這個原則是對繼承的一種保障：繼承不是僅僅為了重複使用父類別的程式碼，而是為了保證「子類別能夠完全取代父類別」。如果子類別的行為和父類別不同，甚至違反了父類別的預期，那麼就會破壞系統的穩定性，這就是違反 LSP 的表現。  </p><h2><span id="里氏替換原則的例子">里氏替換原則的例子</span></h2><p>讓我們來看一個簡單的例子，理解什麼樣的設計違反了里氏替換原則。  </p><h3><span id="錯誤的設計違反里氏替換原則">錯誤的設計，違反里氏替換原則</span></h3><p>假設我們有一個 <code>Bird</code> 類別，以及繼承它的 <code>Penguin</code> 類別：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鳥類的飛行行為</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"Penguins can't fly!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這個例子中，<code>Penguin</code> 類別違反了 LSP，因為當程式預期所有的 <code>Bird</code> 都能飛時，<code>Penguin</code> 的 <code>fly</code> 方法卻會拋出異常，這顯然不是正確的行為。雖然企鵝是鳥類，但它不能飛，這導致了子類別無法正常替換父類別。  </p><h3><span id="正確的設計遵守里氏替換原則">正確的設計，遵守里氏替換原則</span></h3><p>要解決這個問題，我們應該重新思考類別的設計。或許「飛行」不應該是所有鳥類的共同行為，而應該是飛行鳥類的特徵。因此，我們可以將飛行行為從 <code>Bird</code> 類別中移除，並且將其移到專門處理飛行鳥類的類別中：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一般鳥類的屬性與行為</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 飛行行為</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    <span class="comment">// 企鵝的行為，無需實現 fly 方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>經過重新設計後，現在 <code>Penguin</code> 類別不需要再拋出異常，因為它不會被要求飛行，而 <code>FlyingBird</code> 類別則專注於飛行鳥類的行為。這樣的設計遵守了 LSP，因為 <code>Penguin</code> 不再被強迫擁有與其不符合的行為。  </p><h2><span id="為什麼這麼做">為什麼這麼做？</span></h2><p>遵守里氏替換原則能夠讓程式更具穩定性與可預測性。當你的子類別能夠無縫替換父類別時，系統能夠更有效地進行擴展，維護起來也更加容易。  </p><p>不遵守 LSP 的問題在於，當子類別無法替換父類別時，往往會導致難以發現的錯誤。這些錯誤可能在某些特定情境下才會顯現出來，這使得除錯變得非常困難。  </p><p>此外 LSP 的好處在於<strong>保持繼承的正確性與一致性</strong>。當我們設計一個基底類別時，我們期望所有的子類別都能遵循同樣的行為規範，而不是為每一個子類別設定不同的特例。遵守 LSP 意味著我們的設計是穩定且易於預測的，這對於大型專案來說至關重要。  </p><p>當然，過度應用繼承或過於強求遵守 LSP 可能會導致程式碼設計變得複雜，因此在實踐中，我們應該根據具體需求靈活應用這一原則。  </p><h2><span id="實際應用">實際應用</span></h2><p>LSP 在實際應用中是非常常見的，尤其是在框架設計或 API 開發中尤為重要。設計一個良好的框架或函式庫時，確保子類別能夠無縫替換父類別，能夠讓開發者更加輕鬆地進行擴展和修改，而不必擔心破壞現有系統。  </p><p>例如在 GUI 開發中，一個基礎的按鈕類別可能會被許多不同的按鈕類別繼承（如「送出按鈕」或「取消按鈕」）。這些子按鈕應該都能被替換為基礎的按鈕類別，而不會出現意外行為。遵守 LSP 可以讓整個界面的行為更為一致，也讓開發更為順暢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是否曾經遇到過這樣的情況：你寫了一個子類別，卻發現當它被應用於父類別的場景時，程式突然出現了問題？這其實是違反了「里氏替換原則 (Liskov Substitution Principle, LSP)」的例子。LSP 是面向物件設計中的一個重要原則，能幫助我們在使用繼承時
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>設計原則 - 開放封閉原則 Open-Closed Principle</title>
    <link href="https://shengyu7697.github.io/open-closed-principle/"/>
    <id>https://shengyu7697.github.io/open-closed-principle/</id>
    <published>2024-09-15T12:00:00.000Z</published>
    <updated>2024-09-19T13:40:07.101Z</updated>
    
    <content type="html"><![CDATA[<p>在軟體設計中，我們經常面對需求變更的挑戰。想像一下，當客戶突然提出新需求時，你的系統卻因為架構過於死板，導致每次要修改功能都得重新調整大量程式碼。這不僅會耗費時間，還會增加出錯的機會。這時候「開放封閉原則 (Open-Closed Principle, OCP)」就能派上用場，幫助我們的程式保持靈活性，同時又能控制變更帶來的風險。  </p><h2><span id="什麼是開放封閉原則">什麼是開放封閉原則？</span></h2><p>開放封閉原則，簡單來說就是<strong>軟體應該對擴展開放，對修改封閉</strong>。也就是說我們應該設計程式，使其能夠在不修改既有程式碼的情況下，透過擴展來新增功能。  </p><p>換句話說，當我們的需求改變時，應該可以透過增加新類別或新功能來解決，而不是去修改現有的邏輯。這樣的好處是，既能保護原有系統的穩定性，又能快速適應變化。  </p><h2><span id="開放封閉原則的例子">開放封閉原則的例子</span></h2><p>讓我們來看一個不符合開放封閉原則的例子，來感受這個原則的意義。  </p><h3><span id="錯誤的設計違反開放封閉原則">錯誤的設計，違反開放封閉原則</span></h3><p>假設我們在設計一個圖形繪製程式，原本只需要支援兩種圖形——圓形和方形，我們的程式可能會這樣寫：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ShapeType &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeDrawer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(ShapeType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == Circle) &#123;</span><br><span class="line">            <span class="comment">// 畫圓形的邏輯</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Square) &#123;</span><br><span class="line">            <span class="comment">// 畫方形的邏輯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這段程式碼運作良好，但當需求改變，客戶希望支援更多的圖形類型時，我們就必須不斷修改 <code>ShapeDrawer</code> 類別，加入新的條件分支。如果圖形種類越來越多，例如三角形、橢圓與菱形等，這段程式碼會變得越來越臃腫且難以維護。  </p><p>上述例子顯然違反了開放封閉原則。因為每當我們需要新增一種新圖形，都得進行程式碼修改，這不僅增加了錯誤的風險，也讓系統變得更加脆弱。理想的情況下，我們應該能在不改動既有程式碼的情況下，輕鬆地增加新圖形的繪製功能。  </p><h3><span id="正確的設計遵守開放封閉原則">正確的設計，遵守開放封閉原則</span></h3><p>為了符合開放封閉原則，我們可以運用抽象類別與多型的設計來解決這個問題：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 畫圓形的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="comment">// 畫方形的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeDrawer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(<span class="keyword">const</span> Shape&amp; shape)</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這個設計中，<code>ShapeDrawer</code> 不再依賴於具體的圖形類型，所有圖形的繪製邏輯都由各自的類別來負責。如果我們需要新增一種新圖形，例如三角形，我們只需新增一個 <code>Triangle</code> 類別，實作其 <code>draw</code> 方法，而不需要修改 <code>ShapeDrawer</code> 類別。這樣我們就可以輕鬆擴展功能，而不必改動既有的程式碼，符合了開放封閉原則。  </p><h2><span id="為什麼這麼做">為什麼這麼做？</span></h2><p>開放封閉原則帶來的最大好處就是<strong>系統的穩定性與可擴展性</strong>。當我們能夠在不修改現有程式碼的情況下擴展功能時，就能減少意外錯誤的風險，也能保持系統的穩定性。這在大型專案或持續演進的系統中顯得重要。  </p><p>同時，這樣的設計還讓我們的程式更加容易維護和理解。每個圖形的繪製邏輯都被封裝在各自的類別中，遵循單一職責原則 (Single Responsibility Principle)，不會讓 <code>ShapeDrawer</code> 類別變得臃腫不堪。  </p><p>當然，開放封閉原則也有其限制，特別是當我們過度抽象時，可能會使系統設計變得過於複雜。在小型專案中，這種設計的好處可能不那麼明顯，但隨著系統規模增大，這種方式的優勢會逐漸顯現。  </p><h2><span id="實際應用">實際應用</span></h2><p>開放封閉原則廣泛應用於各種場景，尤其是在<strong>框架設計</strong>與<strong>第三方擴展</strong>時非常實用。舉例來說，許多應用程式框架都提供了一系列的抽象介面，開發者可以在不修改框架核心程式碼的情況下，透過實作這些介面來擴展功能，這正是開放封閉原則的應用。  </p><p>同樣地，在一些策略模式或工廠模式的應用中，我們也會看到開放封閉原則的影子。無論是新增業務邏輯、加入新的功能模組，還是替換現有功能，遵守這個原則都能讓我們的系統保持穩定且靈活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在軟體設計中，我們經常面對需求變更的挑戰。想像一下，當客戶突然提出新需求時，你的系統卻因為架構過於死板，導致每次要修改功能都得重新調整大量程式碼。這不僅會耗費時間，還會增加出錯的機會。這時候「開放封閉原則 (Open-Closed Principle, OCP)」就能派上用
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>設計原則 - 單一職責原則 Single Responsibility Principle</title>
    <link href="https://shengyu7697.github.io/single-responsibility-principle/"/>
    <id>https://shengyu7697.github.io/single-responsibility-principle/</id>
    <published>2024-09-14T12:00:00.000Z</published>
    <updated>2024-09-19T00:10:06.671Z</updated>
    
    <content type="html"><![CDATA[<p>在寫程式的過程中，我們經常會遇到一個類別或模組負責太多事情，結果導致程式碼難以維護或修改，這種情況常常被稱為「巨石類別 (God Class)」。當我們需要對程式碼做出任何變更時，這種「巨石類別」會變得相當脆弱，因為它的每一個改動都有可能對其他功能造成影響。這時候，「單一職責原則 (Single Responsibility Principle, SRP)」便能幫助我們解決這個問題。  </p><h2><span id="什麼是單一職責原則">什麼是單一職責原則？</span></h2><p>簡單來說，<strong>單一職責原則強調每個類別或模組應該只負責一件事</strong>，也就是說每個類別應該只專注於它的核心功能。如果一個類別有多於一個原因會導致它需要變更，那麼這個類別就違反了單一職責原則。  </p><p>用白話來說，就是「一個人做好一件事」的概念。在軟體設計中，我們應該避免讓一個類別承擔太多不同的責任，這樣不僅會讓程式碼更具彈性，也更容易進行維護。  </p><h2><span id="單一職責原則的例子">單一職責原則的例子</span></h2><p>讓我們來看一個簡單的例子，理解什麼樣的設計違反了單一職責原則。  </p><h3><span id="錯誤的設計違反單一職責原則">錯誤的設計，違反單一職責原則</span></h3><p>我們可以先從一個不遵守單一職責原則的範例來看。假設你有一個「報告管理」類別，這個類別同時負責產生報告內容和報告的儲存：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReportManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 產生報告的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveToFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將報告儲存至檔案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這個 <code>ReportManager</code> 類別明顯負責了兩件事：一是產生報告，二是將報告儲存至檔案。這樣的設計違反了單一職責原則，因為當你需要修改報告產生邏輯時，可能會影響到報告儲存的邏輯，反之亦然。  </p><p>這種違反單一職責原則的設計會使程式碼變得難以維護。隨著功能增多，我們可能會發現 <code>ReportManager</code> 會變得越來越臃腫，最終變成「巨石類別」，任何改動都會影響整個類別的穩定性。  </p><h3><span id="正確的設計遵守單一職責原則">正確的設計，遵守單一職責原則</span></h3><p>那麼要如何設計一個符合單一職責原則的解決方案呢？我們可以將 <code>ReportManager</code> 的責任拆分成兩個類別，一個專注於報告產生，另一個專注於報告儲存：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReportGenerator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 產生報告的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReportSaver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveToFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將報告儲存至檔案的邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在我們的 <code>ReportGenerator</code> 類別只專注於報告產生，而 <code>ReportSaver</code> 類別則負責儲存報告。這樣的設計遵守了單一職責原則，因為每個類別只負責一件事。當我們需要修改報告產生的邏輯時，並不會影響到報告儲存的功能，反之亦然。  </p><h2><span id="為什麼這麼做">為什麼這麼做？</span></h2><p>單一職責原則的最大好處在於<strong>降低類別之間的耦合度</strong>。當每個類別都只負責一件事時，程式碼變更時不會影響到其他不相關的部分，這樣能夠有效降低系統的出錯機率。這也讓我們的程式碼更具可測試性，因為每個類別都只有單一的責任，單元測試時只需要關注這個類別的核心功能即可。  </p><p>此外，單一職責原則還提升了系統的可維護性。隨著需求的變更，我們能夠更加輕鬆地對系統進行修改，因為我們不必擔心一個類別承擔了太多的責任，導致改動影響整個系統的穩定性。  </p><p>當然，過度拆分職責可能會導致過度設計，特別是在小型專案中，每個功能都被分得太細反而會增加程式碼的複雜性。因此遵守單一職責原則時，需要根據實際需求找到平衡。  </p><h2><span id="實際應用">實際應用</span></h2><p>單一職責原則在實際開發中應用廣泛，尤其是在大型專案或持續演進的系統中尤為重要。無論是類別設計還是模組拆分，遵守單一職責原則能夠有效提升系統的可擴展性與可維護性。  </p><p>例如，在設計軟體框架時，我們會將不同功能的模組分開，確保每個模組只負責單一職責，這樣開發者在擴展功能時，可以很輕鬆地新增或修改特定模組，而不必擔心破壞其他模組的運作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在寫程式的過程中，我們經常會遇到一個類別或模組負責太多事情，結果導致程式碼難以維護或修改，這種情況常常被稱為「巨石類別 (God Class)」。當我們需要對程式碼做出任何變更時，這種「巨石類別」會變得相當脆弱，因為它的每一個改動都有可能對其他功能造成影響。這時候，「單一職
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 訪問者模式 Visitor Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-visitor-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-visitor-pattern/</id>
    <published>2024-09-13T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>想像你是一位探險家，來到了一座神秘的古城。這座城市有著各式各樣的建築：宏偉的宮殿、莊嚴的神廟、繁忙的市集。作為一個訪問者，你想要深入了解每個地方，但每個地方都有其獨特的探索方式。這就像程式世界中的訪問者模式，一種讓你能夠優雅地處理複雜物件結構的設計模式。準備好開始這段奇妙的探索之旅了嗎?  </p><h2><span id="什麼是訪問者模式">什麼是訪問者模式？</span></h2><p>訪問者模式是一種行為設計模式，它允許你在不改變原有物件結構的情況下，定義對這些物件的新操作。這個模式的核心思想是將資料結構和資料操作分離。在這個模式中，訪問者會遍歷不同類型的物件，並對它們進行不同的操作。這樣的好處是可以靈活地新增行為，而不用修改原來的類別。  </p><p>就像我們的探險家例子，訪問者就像是探險家，而被訪問的元素就像是城市中的各個地點。無論你去到哪裡，都能以適合該地點的方式進行探索，而不需要改變這些地點本身。  </p><h2><span id="訪問者模式在繪圖軟體中的應用">訪問者模式在繪圖軟體中的應用</span></h2><p>讓我們透過一個繪圖軟體的例子來深入理解訪問者模式。想像我們正在開發一款繪圖軟體，裡面有各式各樣的圖形，如圓形、矩形和三角形等。這些圖形都有各自的繪圖和顯示方式，但現在我們需要新增一個功能：計算每個圖形的面積。  </p><p>首先我們定義訪問者介面和圖形的基本介面，  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向宣告</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 訪問者基類</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Circle* circle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Rectangle* rectangle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Triangle* triangle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接著我們實現具體的圖形類，這裡的 <code>Circle</code>、<code>Rectangle</code> 和 <code>Triangle</code> 類就是我們所說的”不需要修改的類”。這些類代表了我們的基本圖形，它們的主要職責是維護圖形的基本屬性。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> radius) : radius(radius) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> override </span>&#123;</span><br><span class="line">        visitor-&gt;visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">double</span> width， <span class="keyword">double</span> height) : width(width)， height(height) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> override </span>&#123;</span><br><span class="line">        visitor-&gt;visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> height; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> width， height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangle(<span class="keyword">double</span> base， <span class="keyword">double</span> height) : base(base)， height(height) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> override </span>&#123;</span><br><span class="line">        visitor-&gt;visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getBase</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> base; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> height; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> base， height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然後我們可以實現具體的訪問者，例如計算面積的訪問者，  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 計算面積大小的訪問者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AreaCalculator</span> :</span> <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Circle* circle)</span> override </span>&#123;</span><br><span class="line">        totalArea += <span class="number">3.14159</span> * circle-&gt;getRadius() * circle-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Rectangle* rectangle)</span> override </span>&#123;</span><br><span class="line">        totalArea += rectangle-&gt;getWidth() * rectangle-&gt;getHeight();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Triangle* triangle)</span> override </span>&#123;</span><br><span class="line">        totalArea += <span class="number">0.5</span> * triangle-&gt;getBase() * triangle-&gt;getHeight();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalArea</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> totalArea; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> totalArea = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最後客戶端可以這樣使用來取得所有圖形的面積總合，  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Shape*&gt; shapes = &#123;</span><br><span class="line">        <span class="keyword">new</span> Circle(<span class="number">5</span>)，</span><br><span class="line">        <span class="keyword">new</span> Rectangle(<span class="number">4</span>， <span class="number">6</span>)，</span><br><span class="line">        <span class="keyword">new</span> Triangle(<span class="number">3</span>， <span class="number">4</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    AreaCalculator areaCalculator;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> shape : shapes) &#123;</span><br><span class="line">        shape-&gt;accept(&amp;areaCalculator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Total area: "</span> &lt;&lt; areaCalculator.getTotalArea() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 釋放記憶體</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> shape : shapes) &#123;</span><br><span class="line">        <span class="keyword">delete</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total area: 108.54</span><br></pre></td></tr></table></figure></p><p>透過這種方式，我們可以輕鬆地新增新的操作（如計算周長、繪製圖形等），而不需要修改現有的 <code>Circle</code>、<code>Rectangle</code> 和 <code>Triangle</code> 類。這就是訪問者模式的核心優勢：當我們需要新增新的操作時，我們只需要建立一個新的訪問者類（比如 <code>PerimeterCalculator</code> 或 <code>ShapeDrawer</code>），而不需要改變這些基本圖形類的結構。  </p><p>這種設計使得我們的圖形結構保持穩定，同時允許我們靈活地新增新的操作。例如，如果我們之後想要新增一個計算所有圖形重心的功能，我們只需要建立一個新的 <code>CenterOfGravityCalculator</code> 訪問者，而不需要修改任何現有的圖形類。  </p><h2><span id="訪問者模式在檔案結構分析中的應用">訪問者模式在檔案結構分析中的應用</span></h2><p>另一個常見的應用例子就是檔案結構分析。假設你有一個複雜的檔案系統，裡面包含了檔案（File）和資料夾（Folder）。當你想要統計資料夾內所有檔案的大小，或是對特定類型的檔案進行處理時，訪問者模式就能幫上大忙。</p><p>我們有一個檔案系統，其中包含兩種類型的元素：<code>File</code> 和 <code>Folder</code>。我們需要一個訪問者來遍歷這些元素並計算檔案的大小。</p><p>定義一個訪問者介面 <code>Visitor</code>，其中包含兩個方法，分別對 <code>File</code> 和 <code>Folder</code> 類別進行操作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向宣告</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 訪問者基類</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File* file)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Folder* folder)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定義 <code>File</code> 和 <code>Folder</code> 類別，它們都會有一個 <code>accept</code> 方法來接受訪問者，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 檔案類</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>&#123;</span><br><span class="line">        visitor-&gt;visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">100</span>; <span class="comment">// 假設每個檔案都有大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 資料夾類</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>&#123;</span><br><span class="line">        visitor-&gt;visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFile</span><span class="params">(File* file)</span> </span>&#123;</span><br><span class="line">        files.push_back(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;File*&gt;&amp; getFiles() <span class="keyword">const</span> &#123; <span class="keyword">return</span> files; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;File*&gt; files;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定義具體的訪問者，這個訪問者用來計算檔案總大小，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 計算大小的訪問者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeVisitor</span> :</span> <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(File* file)</span> override </span>&#123;</span><br><span class="line">        totalSize += file-&gt;getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Folder* folder)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> file : folder-&gt;getFiles()) &#123;</span><br><span class="line">            file-&gt;accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTotalSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> totalSize; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後在客戶端中使用訪問者來計算總大小，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file1, file2;</span><br><span class="line">    Folder folder;</span><br><span class="line">    folder.addFile(&amp;file1);</span><br><span class="line">    folder.addFile(&amp;file2);</span><br><span class="line"></span><br><span class="line">    SizeVisitor visitor;</span><br><span class="line">    folder.accept(&amp;visitor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Total size: "</span> &lt;&lt; visitor.getTotalSize() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>透過這種方式，我們可以輕鬆地新增新的操作(如搜尋、統計、結構顯示等)，而不需要修改現有的 File 和 Folder 類。這就是訪問者模式的核心優勢：當我們需要新增新的操作時，我們只需要建立一個新的訪問者類（比如 FileSearcher、FileCounter 或 StructurePrinter），而不需要改變 File 和 Folder 這些基本類的結構。<br>這種設計使得我們的檔案系統結構保持穩定，同時允許我們靈活地新增新的操作。例如，如果我們之後想要新增一個統計特定類型檔案數量的功能，我們只需要建立一個新的 FileTypeCounter 訪問者，而不需要修改 File 和 Folder 類。</p><h2><span id="訪問者模式的優缺點">訪問者模式的優缺點</span></h2><p>訪問者模式就像是一把瑞士軍刀，提供了極大的靈活性。它允許我們輕鬆地新增新的操作，而無需修改現有的類結構。這不僅提高了程式碼的可維護性，還有助於遵守開閉原則。此外它還能將相關的操作集中在訪問者中，讓程式碼更加整潔和易於管理。  </p><p>訪問者模式也有其缺點。它不太適合經常改變結構的系統，因為每當物件結構發生變化，你就必須更新訪問者中的方法。另外如果物件的類型數量很多，訪問者模式會變得難以維護，因為每新增一種類型都需要在訪問者中新增對應的方法。  </p><h2><span id="總結">總結</span></h2><p>訪問者模式特別適合在物件結構穩定，但需要經常增加行為的情況下使用。透過將操作與物件分離，我們可以更輕鬆地擴展系統功能，而不會影響原有的結構。不過這個模式也有其適用範圍，過於複雜的結構變化可能會使訪問者模式的維護成本變得很高。因此選擇是否使用訪問者模式時，需要根據具體需求來權衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你是一位探險家，來到了一座神秘的古城。這座城市有著各式各樣的建築：宏偉的宮殿、莊嚴的神廟、繁忙的市集。作為一個訪問者，你想要深入了解每個地方，但每個地方都有其獨特的探索方式。這就像程式世界中的訪問者模式，一種讓你能夠優雅地處理複雜物件結構的設計模式。準備好開始這段奇妙的
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 原型模式 Prototype Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-prototype-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-prototype-pattern/</id>
    <published>2024-09-12T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>想像一下你手上有一個心愛的玩偶，這個玩偶有著獨特的外觀、材質和手感。如果你想要再擁有一個一模一樣的玩偶，你會怎麼做呢？重新製作一個可能需要花費很多時間與精力，但如果有一個神奇的「複製器」，只要按一下按鈕，就能夠完美複製出另一個相同的玩偶，那該有多方便！這就是「原型模式（Prototype Pattern）」在軟體設計中的核心思想。這種模式讓我們能夠快速複製已經存在的物件，而不需要從頭再建立一遍。  </p><h2><span id="什麼是原型模式">什麼是原型模式？</span></h2><p>原型模式是一種建立型設計模式，它允許我們透過複製現有的物件來建立新物件，而不是透過傳統的方式來構建新物件。這種方式特別適合於物件建立成本高昂或結構複雜的情境。具體來說原型模式包含了一個介面，這個介面定義了複製自身的能力。每個實現這個介面的物件都能夠建立一個自己的複本，並且複製出來的新物件與原始物件在狀態上是相同的。  </p><p>在C++中，這通常是透過深拷貝或淺拷貝來實現的。深拷貝會複製物件中的所有資料，包括內部指標所指向的資源，而淺拷貝則只複製物件的基本結構，而共享內部資源。  </p><p>想像你正在開發一個角色扮演遊戲。遊戲中有各種各樣的怪物，每種怪物都有自己的屬性和技能。如果每次需要新怪物時都要從頭建立，傳入很多參數跟設定數值，那將是一個繁瑣的過程。這時原型模式就能派上用場了。  </p><p>再舉個例子，想像你正在開發一個圖形設計軟體，其中有些常用的圖形，例如矩形，客戶端在使用時可能需要頻繁地建立相似的矩形，而這些矩形的基本屬性是相同的（顏色、寬度、高度），為了提高客戶端的工作效率，就能夠使用原型模式快速複製產生新的矩形物件。  </p><p>這個模式的基本角色包括：    </p><ol><li>原型（Prototype）：宣告一個複製自己本身的介面。  </li><li>具體原型（Concrete Prototype）：實現複製自己本身的方法。  </li><li>客戶端（Client）：透過呼叫原型的複製方法來取得新的物件。  </li></ol><h2><span id="原型模式在遊戲角色建立中的應用">原型模式在遊戲角色建立中的應用</span></h2><p>讓我們以遊戲開發為例，來看看原型模式的應用。一個典型的角色扮演遊戲（RPG）中，玩家可以選擇不同的職業，每個職業都有其獨特的屬性、技能和裝備。如果每次建立一個新角色都要從頭設定這些屬性，那將是非常耗時的事情。但如果我們能夠建立一個基礎角色的原型，然後透過複製這個原型來產生新角色，就能夠大大簡化這個過程。  </p><p>首先我們定義一個 <code>Prototype</code> 介面，它包含了一個 <code>clone()</code> 方法，這個方法用來複製物件，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型 Prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharacterPrototype</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CharacterPrototype* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showAttributes</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~CharacterPrototype() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們建立一個具體的角色類別，例如一個戰士角色，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體原型 Concrete Prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warrior</span> :</span> <span class="keyword">public</span> CharacterPrototype &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> strength;</span><br><span class="line">    <span class="keyword">int</span> defense;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> weapon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Warrior(<span class="keyword">int</span> str, <span class="keyword">int</span> def, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; weap)</span><br><span class="line">        : strength(str), defense(def), weapon(weap) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CharacterPrototype* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Warrior(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAttributes</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Warrior with strength: "</span> &lt;&lt; strength</span><br><span class="line">                  &lt;&lt; <span class="string">", defense: "</span> &lt;&lt; defense</span><br><span class="line">                  &lt;&lt; <span class="string">", weapon: "</span> &lt;&lt; weapon &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們在客戶端可以使用這個角色原型來建立新角色，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立初始角色</span></span><br><span class="line">    CharacterPrototype* originalWarrior = <span class="keyword">new</span> Warrior(<span class="number">100</span>, <span class="number">50</span>, <span class="string">"Sword"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 複製角色</span></span><br><span class="line">    CharacterPrototype* clonedWarrior = originalWarrior-&gt;clone();</span><br><span class="line"></span><br><span class="line">    originalWarrior-&gt;showAttributes();  <span class="comment">// 輸出：Warrior with strength: 100, defense: 50, weapon: Sword</span></span><br><span class="line">    clonedWarrior-&gt;showAttributes();    <span class="comment">// 輸出：Warrior with strength: 100, defense: 50, weapon: Sword</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> originalWarrior;</span><br><span class="line">    <span class="keyword">delete</span> clonedWarrior;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warrior with strength: 100, defense: 50, weapon: Sword</span><br><span class="line">Warrior with strength: 100, defense: 50, weapon: Sword</span><br></pre></td></tr></table></figure></p><p>在這個例子中，我們建立了一個戰士角色作為原型，並使用原型的 <code>clone()</code> 方法產生了一個一模一樣的新角色。這樣，我們不需要每次建立新角色時都手動設定屬性，而是透過簡單的複製操作快速產生所需的角色。  </p><h2><span id="原型模式的優缺點">原型模式的優缺點</span></h2><p>原型模式的一大優點是它提供了一種高效的物件建立方式，特別是在需要多次建立類似物件的情況下，能夠節省大量時間和資源。由於原型模式直接複製現有的物件，我們可以保證新物件與原始物件具有相同的狀態，這在某些需要精確控制物件狀態的場景中尤為重要。  </p><p>然而原型模式的缺點在於複製過程的複雜性。當物件的結構非常複雜或包含指標、動態分配的資源時，正確地實現深拷貝可能會變得困難。這要求開發者對物件的內部結構有非常清晰的理解，並且小心處理拷貝過程中的細節。另外如果物件中包含了不應該被複製的部分，或需要在複製後進行一些特定處理，那麼在實際應用中可能會遇到額外的挑戰。  </p><p>整理來說原型模式在適合的情境下能夠極大地提高開發效率，但也需要謹慎使用，確保在複製物件時沒有引入額外的複雜度或潛在的錯誤。  </p><h2><span id="總結">總結</span></h2><p>原型模式在我們的日常生活中也隨處可見，影印機複印文件時，原始文件就是原型，複印出來的每一份都是複製品。在細胞分裂中，新的細胞是從原有細胞複製而來的。這些例子都體現了原型模式的核心思想：透過複製現有的物件來建立新物件。  </p><p>原型模式是一種強大而靈活的建立型設計模式，適合於那些需要複製大量相似物件的應用場景。透過原型模式，我們可以輕鬆地產生具有相同屬性和狀態的新物件，從而提高開發效率，降低複雜度。然而在使用時需要注意物件複製過程中的潛在風險，特別是涉及到深拷貝和資源管理時。  </p><p>設計模式是解決問題的工具，而不是目的本身。靈活運用才能寫出既優雅又實用的程式碼。在軟體開發的道路上，讓我們能像原型模式一樣，在「複製」中不斷成長，創造出屬於自己的精彩作品。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像一下你手上有一個心愛的玩偶，這個玩偶有著獨特的外觀、材質和手感。如果你想要再擁有一個一模一樣的玩偶，你會怎麼做呢？重新製作一個可能需要花費很多時間與精力，但如果有一個神奇的「複製器」，只要按一下按鈕，就能夠完美複製出另一個相同的玩偶，那該有多方便！這就是「原型模式（Pr
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 享元模式 Flyweight Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-flyweight-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-flyweight-pattern/</id>
    <published>2024-09-11T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>當你玩大型多人線上遊戲（MMO）時，畫面上有成百上千個玩家角色，擁有著不同的裝備、武器和坐騎，你有沒有想過，遊戲引擎是如何管理這麼多個體的？如果每一個角色都佔據完整的記憶體空間，電腦恐怕早已爆掉！這背後的祕密之一，就是我們今天要講的「享元模式」。  </p><h2><span id="什麼是享元模式">什麼是享元模式？</span></h2><p>享元模式（Flyweight Pattern）是一種結構型設計模式，目的在減少物件建立時佔用的記憶體空間。它透過共享大量相似物件中的共通部分來降低記憶體使用，特別適合用在場景中有大量細微差異的物件。這樣的做法不僅節省了資源，也讓系統執行更有效率。  </p><p>在享元模式中，會將可共享的部分抽出，放到單一實體中進行管理，而非每個物件都擁有自己的複本。對於那些不可共享的部分，則會透過引數進行傳遞，這樣就能避免重複建立類似的物件。  </p><p>享元（Flyweight）這個術語源自拳擊界，在拳擊比賽中，Flyweight 指的是一個較輕量級(57kg以下)的選手級別。這個詞在設計模式中被借用，是因為享元模式的核心理念與輕量的概念相吻合：目的是減輕系統的記憶體負擔，讓程式變得更「輕」，更高效。享元模式透過共享物件的內部狀態，達到了減少記憶體佔用的效果。  </p><h2><span id="享元模式在圖形系統中的應用">享元模式在圖形系統中的應用</span></h2><p>最常見的享元模式例子之一，就是在圖形系統中處理複雜的場景。想像你正在開發一個繪圖應用程式，必須在畫布上顯示上千個相同的圓形。每個圓的顏色、大小和座標可能不同，但圓的輪廓和基本形狀是相同的。我們可以利用享元模式，來共享這些圓的形狀，只根據需要改變其他屬性來展示不同的圓形。  </p><p>首先我們需要定義一個共享的「圓形」物件，  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圓形基類，提供繪製方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="built_in">std</span>::<span class="built_in">string</span> color) : color(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing "</span> &lt;&lt; color &lt;&lt; <span class="string">" circle at ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">") with radius "</span> &lt;&lt; radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然後我們可以建立一個「圓形工廠」，負責管理和提供共享的圓形物件，  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Circle&gt; getCircle(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color) &#123;</span><br><span class="line">        <span class="keyword">if</span> (circles.find(color) == circles.end()) &#123;</span><br><span class="line">            circles[color] = <span class="built_in">std</span>::make_shared&lt;Circle&gt;(color);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating circle of color: "</span> &lt;&lt; color &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles[color];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Circle&gt;&gt; circles;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下來客戶端可以透過 <code>CircleFactory</code> 來取得不同顏色的圓形，並指定其座標和半徑，這樣便可以有效地共享相同顏色的圓形實體，  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CircleFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> redCircle = factory.getCircle(<span class="string">"Red"</span>);</span><br><span class="line">    redCircle-&gt;draw(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> blueCircle = factory.getCircle(<span class="string">"Blue"</span>);</span><br><span class="line">    blueCircle-&gt;draw(<span class="number">20</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> anotherRedCircle = factory.getCircle(<span class="string">"Red"</span>);</span><br><span class="line">    anotherRedCircle-&gt;draw(<span class="number">30</span>, <span class="number">30</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Creating circle of color: Red</span><br><span class="line">Drawing Red circle at (10, 10) with radius 5</span><br><span class="line">Creating circle of color: Blue</span><br><span class="line">Drawing Blue circle at (20, 20) with radius 10</span><br><span class="line">Drawing Red circle at (30, 30) with radius 15</span><br></pre></td></tr></table></figure></p><p>這裡我們重複使用了紅色圓形，而不必每次都建立新的紅色圓形。程式輸出將顯示紅色圓形只建立了一次，這就是享元模式的精髓——重複利用可共享的部分，節省記憶體。  </p><h2><span id="享元模式的優缺點">享元模式的優缺點</span></h2><p>享元模式最大的優點，當然就是<strong>節省記憶體</strong>。當我們需要建立大量相似的物件時，這種模式可以極大減少不必要的記憶體消耗，提升程式的效能。例如在繪圖系統、文字處理器，甚至是遊戲引擎中，都可以看到享元模式的影子。只要那些物件之間有許多相同的部分，就能採用享元模式進行共享。  </p><p>然而這種共享資源的方式也不是沒有代價。享元模式的<strong>複雜性</strong>較高，因為需要將物件分為共享的內部狀態與不可共享的外部狀態。開發人員在使用時必須額外考慮如何管理這些狀態，避免產生混淆。另外在某些情況下，為了維護享元物件的內部狀態一致性，可能會導致更多的<strong>同步問題</strong>，特別是在多執行緒的環境下。  </p><h2><span id="總結">總結</span></h2><p>享元模式是一種在需要大量建立相似物件的場景下非常有用的設計模式，透過共享物件來大幅減少記憶體消耗。在像是繪圖系統、遊戲開發等領域，我們可以利用這個模式來有效管理大量物件。然而，享元模式的實現需要仔細設計和管理內部狀態與外部狀態的區別，以避免增加不必要的複雜度。這個模式不會讓你的程式「飛起來」，但絕對能讓它執行得更順暢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你玩大型多人線上遊戲（MMO）時，畫面上有成百上千個玩家角色，擁有著不同的裝備、武器和坐騎，你有沒有想過，遊戲引擎是如何管理這麼多個體的？如果每一個角色都佔據完整的記憶體空間，電腦恐怕早已爆掉！這背後的祕密之一，就是我們今天要講的「享元模式」。  &lt;/p&gt;
&lt;h2&gt;&lt;sp
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 解釋器模式 Interpreter Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-interpreter-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-interpreter-pattern/</id>
    <published>2024-09-10T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>大家有沒有想過當你在終端機輸入指令時，電腦是如何理解並執行這些指令的？或者當你使用正則表達式搜尋文字時，背後的機制是什麼？這些看似神奇的功能背後，其實都隱藏著一個強大而優雅的設計模式，那就是解釋器模式 Interpreter Pattern，今天就來聊聊這個模式，幫助我們理解當電腦「讀懂」我們的指令時背後的魔法。  </p><h2><span id="什麼是解釋器模式">什麼是解釋器模式？</span></h2><p>解釋器模式是一種行為型設計模式，主要用來解析語言、處理簡單語法規則的。這個模式背後的想法其實很簡單：我們定義一套「語法規則」，然後讓每個「字元」或「符號」有自己專屬的解釋方式。這樣我們就能依照語法，逐步分析出我們想要的結果。  </p><p>打個比方，就像我們學習一種新語言時，會先學習單字，接著組合句子，最後可以用來進行溝通。解釋器模式就像是這個過程的數位版，先定義每個「單字」的意思，再教你如何解釋這些字。  </p><h2><span id="解釋器模式在計算機中的應用">解釋器模式在計算機中的應用</span></h2><p>計算機應該是最能體現解釋器模式的例子之一。想像你有一個簡單的計算機，輸入表達式如「2 + 3 * 4」，然後計算出結果。解釋器模式就可以幫助我們將這些數字與運算子號組合成一個能夠「理解」的語法樹。  </p><p>首先先定義一個 <code>Expression</code> 介面，它會有一個 <code>interpret()</code> 方法。這個方法負責對數字和符號進行解釋，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象表達式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Expression() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著定義具體的 <code>NumberExpression</code>（數字表達式）和 <code>OperatorExpression</code>（運算子表達式）。數字表達式會簡單地回傳它自己的值，而運算子表達式則會對兩個子表達式進行計算，比如加法、乘法等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 數字表達式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> :</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumberExpression(<span class="keyword">int</span> num) : number(num) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法表達式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> :</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddExpression(Expression* l, Expression* r) : left(l), right(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;interpret() + right-&gt;interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法表達式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiplyExpression</span> :</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MultiplyExpression(Expression* l, Expression* r) : left(l), right(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;interpret() * right-&gt;interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在前面已經定義了基礎的 NumberExpression、AddExpression 和 MultiplyExpression 類別。接下來我們在客戶端來實際使用這些表達式，讓整個流程完整起來。  </p><p>我們會有一個解析器來遍歷表達式，並一步步解釋每個部分。假設我們要處理一個簡單的表達式「2 + 3」，客戶端的邏輯會像下面這樣：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立一個表示數字2的NumberExpression</span></span><br><span class="line">    Expression* num1 = <span class="keyword">new</span> NumberExpression(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立一個表示數字3的NumberExpression</span></span><br><span class="line">    Expression* num2 = <span class="keyword">new</span> NumberExpression(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立一個表示加法的AddExpression，將兩個數字作為參數傳入</span></span><br><span class="line">    Expression* addExpr = <span class="keyword">new</span> AddExpression(num1, num2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = addExpr-&gt;interpret();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 + 3 = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Expression* mulExpr = <span class="keyword">new</span> MultiplyExpression(num1, num2);</span><br><span class="line">    result = mulExpr-&gt;interpret();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 * 3 = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 釋放記憶體</span></span><br><span class="line">    <span class="keyword">delete</span> num1;</span><br><span class="line">    <span class="keyword">delete</span> num2;</span><br><span class="line">    <span class="keyword">delete</span> addExpr;</span><br><span class="line">    <span class="keyword">delete</span> mulExpr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出，當我們將表達式「2 + 3」傳給計算機時，解釋器就會根據我們定義的語法規則一步步處理，最終給出結果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 + 3 = 5</span><br><span class="line">2 * 3 = 6</span><br></pre></td></tr></table></figure></p><p>在這個範例中，客戶端的角色就是負責將表達式拼接在一起，然後使用解釋器模式的物件來完成運算。這樣任何新加入的運算子或表達式，只需要擴展 Expression 類別，而不用改動客戶端的邏輯，保持程式的靈活性和可維護性。  </p><h2><span id="解釋器模式的優缺點">解釋器模式的優缺點</span></h2><p>說到解釋器模式的優點，它最大的魅力就在於可以輕鬆地擴展和修改語法規則。比如我們可以在不改變原有架構的情況下，輕鬆加入新的運算子號或功能，這讓解釋器模式在處理語法解析時非常靈活。  </p><p>解釋器模式的缺點也很明顯。當語法規則變得越來越複雜時，類別的數量會激增，這可能導致程式碼的維護和理解變得困難。另外解釋器模式的效能並不高，尤其是當處理大規模語法時，效能的瓶頸會更加明顯。  </p><h2><span id="總結">總結</span></h2><p>解釋器模式就像一個小型語法解析器，適合用來處理簡單的語法規則，像是計算機這樣的場景。它的擴展性讓我們可以在程式中輕鬆加入更多規則，但同時也要留意其效能和維護性。對於那些需要頻繁變更規則、處理複雜語法的情況，解釋器模式提供了一個簡潔且靈活的解決方案。  </p><p>現在使用解釋器模式的情境比以前少了很多。主要是因為解釋器模式通常用在處理自定義的語法或簡單的語言規則上，而現在有很多成熟的解析工具和函式庫可以直接使用，例如正則表達式、Lex、Yacc 等等，這些工具提供了更強大、效能更高的解決方案，因此不再需要自己從頭設計和實現一個語法解析系統。  </p><p>解釋器模式的缺點是當語法規則變得複雜時，維護成本會上升，因此現代系統往往採用專用解析器或虛擬機器（例如 Java 虛擬機器或 JavaScript 引擎），因此手動實現解釋器模式的必要性變少了。  </p><p>儘管如此，解釋器模式在某些特定情境中仍有用武之地，特別是在需要處理簡單且可擴展的語法時，或者需要快速實現自定義的 DSL（Domain-Specific Language）時，它仍是一個不錯的選擇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家有沒有想過當你在終端機輸入指令時，電腦是如何理解並執行這些指令的？或者當你使用正則表達式搜尋文字時，背後的機制是什麼？這些看似神奇的功能背後，其實都隱藏著一個強大而優雅的設計模式，那就是解釋器模式 Interpreter Pattern，今天就來聊聊這個模式，幫助我們理
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 橋接模式 Bridge Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-bridge-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-bridge-pattern/</id>
    <published>2024-09-09T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>想像一下你家裡的電視遙控器，這個遙控器可以控制不同品牌的電視，遙控器本身的功能可能有：開機、關機、調整音量等，甚至隨著需求增加新的按鈕或功能。而電視的功能可能會隨著品牌或型號不同而有所變化。遙控器就像橋接這些不同電視的中介，讓使用者不必考慮每台電視內部的具體細節，只需要知道按下按鈕會有什麼效果。這樣的設計就是「橋接模式」的精髓：把「操作」與「具體實現」分開，讓兩者可以獨立發展。  </p><h2><span id="什麼是橋接模式">什麼是橋接模式？</span></h2><p>橋接模式是一種結構型設計模式，它的主要目的是將抽象部分與實現部分分離，使它們都可以獨立地變化。簡單來說這個模式可以讓你將「抽象層次」和「具體實作」分離開來，以便兩者可以各自演化而不必互相依賴。當你需要擴充系統時，無論是修改抽象部分還是實作部分，都能簡單且獨立進行。</p><p>在程式設計中，當你遇到一個類別因為實作過於複雜或多樣化而導致結構僵化時，你可以透過橋接模式將這些實作細節封裝到一個「實作介面」中，並讓抽象的類別持有該介面，從而達到靈活擴展的效果。橋接模式就像是在兩個獨立變化的維度之間搭建了一座橋樑。這座橋樑使得這兩個維度可以各自獨立地變化，而不會相互影響。  </p><p>這個模式的基本角色包括：  </p><ol><li>抽象部分(Abstraction)：定義了抽象的介面。維護一個對實現者(Implementor)物件的引用。  </li><li>精煉抽象(Refined Abstraction)：擴展抽象類，可以新增更多的功能。  </li><li>實現者(Implementor)：定義實現類的介面，該介面不一定要與抽象類的介面完全一致。通常只提供基本操作，而抽象類定義的介面可能會做更多更複雜的操作。  </li><li>具體實現(Concrete Implementor)：實現實現者介面並提供具體實現。  </li></ol><h2><span id="橋接模式在遊戲開發中的應用">橋接模式在遊戲開發中的應用</span></h2><p>橋接模式經常出現在需要靈活擴展功能的場景中。例如，在圖形繪製的應用中，我們可以有不同的形狀（比如圓形、方形），而每一種形狀可能需要用不同的方式呈現（比如螢幕顯示或列印）。在跨平台GUI系統中，不同作業系統有不同的實現方式。在資料庫程式中，可以切換不同的資料庫系統，對應到不同的資料庫介面，而不影響上層業務邏輯。  </p><p>這邊我們以一個遊戲開發的例子來說明橋接模式。假設我們正在開發一個角色扮演遊戲，遊戲中有不同的角色(如戰士、法師)和不同的武器(如劍、法杖)。我們希望能夠自由地組合角色和武器，而不是為每種組合都建立一個新的類別。透過橋接模式，我們可以將「角色」與「武器」分開，未來當我們需要新增角色或武器方式時，就不必重新組合所有的類別，達到更好的擴展性。  </p><p>以下是使用橋接模式實現這個需求的步驟：  </p><p>首先我們定義武器的抽象介面，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象部分 Abstraction</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Weapon() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們實現具體的武器類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sword</span> :</span> <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"揮舞劍攻擊"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span> :</span> <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用法杖施法"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們定義角色的抽象類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Weapon* weapon;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Character(Weapon* w) : weapon(w) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Character() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後我們實現具體的角色類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warrior</span> :</span> <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Warrior(Weapon* w) : Character(w) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"戰士"</span>;</span><br><span class="line">        weapon-&gt;use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mage</span> :</span> <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mage(Weapon* w) : Character(w) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"法師"</span>;</span><br><span class="line">        weapon-&gt;use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我們可以在客戶端程式碼中自由組合角色和武器，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Weapon* sword = <span class="keyword">new</span> Sword();</span><br><span class="line">    Weapon* staff = <span class="keyword">new</span> Staff();</span><br><span class="line">    </span><br><span class="line">    Character* warrior = <span class="keyword">new</span> Warrior(sword);</span><br><span class="line">    Character* mage = <span class="keyword">new</span> Mage(staff);</span><br><span class="line">    </span><br><span class="line">    warrior-&gt;fight();  <span class="comment">// 輸出: 戰士揮舞劍攻擊</span></span><br><span class="line">    mage-&gt;fight();     <span class="comment">// 輸出: 法師使用法杖施法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 甚至可以讓戰士使用法杖，或讓法師使用劍</span></span><br><span class="line">    Character* warriorWithStaff = <span class="keyword">new</span> Warrior(staff);</span><br><span class="line">    Character* mageWithSword = <span class="keyword">new</span> Mage(sword);</span><br><span class="line">    </span><br><span class="line">    warriorWithStaff-&gt;fight();  <span class="comment">// 輸出: 戰士使用法杖施法</span></span><br><span class="line">    mageWithSword-&gt;fight();     <span class="comment">// 輸出: 法師揮舞劍攻擊</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 釋放記憶體</span></span><br><span class="line">    <span class="keyword">delete</span> sword;</span><br><span class="line">    <span class="keyword">delete</span> staff;</span><br><span class="line">    <span class="keyword">delete</span> warrior;</span><br><span class="line">    <span class="keyword">delete</span> mage;</span><br><span class="line">    <span class="keyword">delete</span> warriorWithStaff;</span><br><span class="line">    <span class="keyword">delete</span> mageWithSword;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">戰士揮舞劍攻擊</span><br><span class="line">法師使用法杖施法</span><br><span class="line">戰士使用法杖施法</span><br><span class="line">法師揮舞劍攻</span><br></pre></td></tr></table></figure></p><p>在這個遊戲開發的例子中，就像是在角色（Character）和武器（Weapon）之間搭建一座「橋樑」。  </p><p>橋的一端是抽象部分（Abstraction），這一端是由 Character 類別及其子類（Warrior 和 Mage）所組成。這代表了角色的抽象，定義了角色應該具有的行為（如 <code>fight()</code> 方法）。  </p><p>橋的另一端是實現部分（Implementation），這一端是由 Weapon 介面及其具體實現（Sword 和 Staff）組成。這代表了武器的實現，定義了武器應該如何被使用（如 <code>use()</code> 方法）。  </p><p>橋樑本身的核心是在 Character 類中的 <code>Weapon* weapon</code> 成員變數。這個成員變數將抽象部分（角色）和實現部分（武器）連接起來。  </p><p>透過橋接模式，我們可以新增新的角色（如弓箭手）或新的武器（如弓箭），而不需要修改現有的程式碼，實現了角色和武器可以獨立變化。任何角色都可以使用任何武器，這種組合是在執行時決定的，而不是在編譯時。透過橋接模式還能減少類別數量，如果不使用橋接模式，我們可能需要為每種角色與武器組合建立一個類別（如 WarriorWithSword， MageWithStaff 等），這會導致類別數量的急劇增加。  </p><p>所以這個橋接模式實際上是一種靈活的連接機制，它允許角色和武器這兩個維度獨立變化，同時又能靈活地組合在一起。這就是橋接模式的核心思想：將抽象部分與其實現部分分離，使它們都可以獨立地變化。  </p><h2><span id="橋接模式的優缺點">橋接模式的優缺點</span></h2><p>橋接模式最大的優點在於它讓抽象與實作分離，因此可以靈活地新增或修改兩者中的任意一方，而不會影響到另一方。這種鬆耦合的設計使得系統的擴展性大大提高，特別是在面對複雜的物件結構或多樣化需求時，它能有效地減少程式碼重複，並且讓系統維護變得更加容易。  </p><p>橋接模式也並非在所有情況下都是最佳選擇。當你的系統結構簡單、需求較為固定時，這種設計可能會增加不必要的複雜度。另外，由於引入了額外的抽象層，開發初期可能會需要更多的規劃和設計，這在某些情況下會稍微增加開發的難度。  </p><h2><span id="總結">總結</span></h2><p>橋接模式特別適合那些需要同時處理多個維度變化的系統。它讓抽象和實作分離，使得系統可以更靈活地演進。在現實世界中，當你面對多重需求的擴展時，橋接模式能讓你輕鬆應對各種變化，避免系統變得難以維護或過於複雜。透過合理的使用橋接模式，你可以在保持系統簡潔的同時，獲得更大的靈活性與可擴展性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像一下你家裡的電視遙控器，這個遙控器可以控制不同品牌的電視，遙控器本身的功能可能有：開機、關機、調整音量等，甚至隨著需求增加新的按鈕或功能。而電視的功能可能會隨著品牌或型號不同而有所變化。遙控器就像橋接這些不同電視的中介，讓使用者不必考慮每台電視內部的具體細節，只需要知道
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 責任鏈模式 Chain of Responsibility Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-chain-of-responsibility-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-chain-of-responsibility-pattern/</id>
    <published>2024-09-08T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>想像你在公司工作，遇到一個問題，你先向主管反映，如果主管無法解決，再往上報告給更高層級的主管，直到有人能解決問題。這就是「責任鏈模式」的核心概念。這種模式允許你把任務逐層傳遞，直到某個物件可以處理它。在軟體設計中，這可以讓系統更加靈活，避免固定的條件判斷，提升維護性。  </p><h2><span id="什麼是責任鏈模式">什麼是責任鏈模式？</span></h2><p>責任鏈模式是一種行為型設計模式，允許多個物件按順序處理請求。每個物件有機會決定是否處理請求，或者將其轉交給下一個物件。這樣一來我們可以將不同的職責模組化，讓每個物件專注於自己的職責範圍，而不用關心整個處理流程。  </p><p>想像你正在玩一個熱門的多人線上遊戲。當你遇到問題需要幫助時，你可能會先詢問遊戲內的自動客服系統。如果自動客服無法解決，問題會被轉到人工客服。如果人工客服也無法處理，問題可能會被上報給技術支援團隊。這就是一個典型的責任鏈模式應用場景。  </p><h2><span id="責任鏈模式在客戶支援系統中的應用">責任鏈模式在客戶支援系統中的應用</span></h2><p>一個常見的應用例子是客戶支援系統，當客戶送出問題時，問題可能由多個不同層級的支援人員來處理：自動客服、人工客服、技術支援團隊等。每個層級都會檢查問題，如果無法解決，就會向上級遞交，直到問題被解決。  </p><p>首先我們定義一個抽象的處理者類，每個處理者 Handler（如客服）都有一個處理請求的方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 處理者 Handler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CustomerServiceHandler* nextHandler;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~CustomerServiceHandler() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(CustomerServiceHandler* handler)</span> </span>&#123;</span><br><span class="line">        nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們實現具體的處理者類，具體的 Handler 如自動客服、人工客服和技術支援團隊繼承這個介面，並實現處理方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體處理者 Concrete Handlers</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomatedSystem</span> :</span> <span class="keyword">public</span> CustomerServiceHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="string">"簡單問題"</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"自動系統：我可以回答這個簡單問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanAgent</span> :</span> <span class="keyword">public</span> CustomerServiceHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="string">"複雜問題"</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"人工客服：我來處理這個複雜問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TechnicalSupport</span> :</span> <span class="keyword">public</span> CustomerServiceHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="string">"技術問題"</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"技術支援團隊：我們會深入研究並解決這個問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;handleRequest(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"無法解決這個問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後客戶端可以這樣使用，當客戶發出請求時，系統會從自動客服開始，如果無法處理，請求會傳遞到下一個層級，直到問題解決，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立三個處理者</span></span><br><span class="line">    AutomatedSystem* autoSystem = <span class="keyword">new</span> AutomatedSystem();</span><br><span class="line">    HumanAgent* humanAgent = <span class="keyword">new</span> HumanAgent();</span><br><span class="line">    TechnicalSupport* techSupport = <span class="keyword">new</span> TechnicalSupport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 設定責任鏈</span></span><br><span class="line">    autoSystem-&gt;setNext(humanAgent);</span><br><span class="line">    humanAgent-&gt;setNext(techSupport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 測試不同請求</span></span><br><span class="line">    autoSystem-&gt;handleRequest(<span class="string">"簡單問題"</span>);</span><br><span class="line">    autoSystem-&gt;handleRequest(<span class="string">"複雜問題"</span>);</span><br><span class="line">    autoSystem-&gt;handleRequest(<span class="string">"技術問題"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> autoSystem;</span><br><span class="line">    <span class="keyword">delete</span> humanAgent;</span><br><span class="line">    <span class="keyword">delete</span> techSupport;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自動系統：我可以回答這個簡單問題。</span><br><span class="line">人工客服：我來處理這個複雜問題。</span><br><span class="line">技術支援團隊：我們會深入研究並解決這個問題。</span><br></pre></td></tr></table></figure></p><h2><span id="責任鏈模式的優缺點">責任鏈模式的優缺點</span></h2><p>責任鏈模式的一大優點是它讓系統更加靈活。新增一個處理者 Handler 不需要修改其他 Handler 的程式碼，只需要在責任鏈中插入新的 Handler 即可，這極大地提高了擴展性。同時 Handler 之間的耦合度降低，每個 Handler 只專注於自己能解決的問題。  </p><p>然而這個模式也有一些的缺點。如果責任鏈過長請求可能會經過很多 Handler，增加了系統的處理時間。此外如果沒有適當的終止條件，請求可能會在處理鏈中無限傳遞。  </p><h2><span id="總結">總結</span></h2><p>責任鏈模式讓我們能夠將職責分散到不同的處理者 Handler 中，提升了系統的可擴展性和維護性。在某些需要多層處理的場景，像是客戶支援系統或是事件處理系統中，這是一種非常有效的解決方案。這個模式避免了一堆 <code>if-else</code> 的條件判斷，讓系統更靈活但也需要注意過長的處理鏈條可能帶來的效率問題。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你在公司工作，遇到一個問題，你先向主管反映，如果主管無法解決，再往上報告給更高層級的主管，直到有人能解決問題。這就是「責任鏈模式」的核心概念。這種模式允許你把任務逐層傳遞，直到某個物件可以處理它。在軟體設計中，這可以讓系統更加靈活，避免固定的條件判斷，提升維護性。  &lt;
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 備忘錄模式 Memento Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-memento-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-memento-pattern/</id>
    <published>2024-09-07T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>假如你正在玩一個遊戲，過了一個困難的關卡，突然間手滑點錯選項，整個進度被重置，你會不會希望有個「存檔」功能讓你可以回到那個關卡？這正是備忘錄模式 Memento Pattern 可以幫助我們解決的問題。備忘錄模式讓我們可以在需要時保存某個物件的狀態，並在必要時恢復到之前的狀態，像是一個系統的「後悔藥」。  </p><h2><span id="什麼是備忘錄模式">什麼是備忘錄模式？</span></h2><p>備忘錄模式是一種行為型設計模式，用來保存物件的狀態，這樣就可以在未來的某個時刻還原這些狀態。這個模式提供了一個方法讓物件能夠保存自己的狀態，並且在不違反封裝原則的情況下將其恢復。備忘錄模式可以想像成一個「快照」，讓我們可以回到某個特定的時間點，而不用擔心破壞系統的其他部分。  </p><p>這個模式的基本角色包括：  </p><ol><li>Originator（發起者）：擁有狀態並可以建立或恢復備忘錄。  </li><li>Memento（備忘錄）：保存Originator的內部狀態，並且只有Originator可以訪問它。  </li><li>Caretaker（照顧者）：負責管理備忘錄，但不會修改其內容，只會在需要時請求Originator恢復狀態。  </li></ol><h2><span id="備忘錄模式在文字編輯器中的應用">備忘錄模式在文字編輯器中的應用</span></h2><p>一個很常見的應用例子就是文字編輯器中的「復原」與「重做」功能。當你編輯檔案時，每一次的修改都可以被記錄下來，這樣當你需要復原時，可以回到先前的狀態。讓我們用一個簡單的C++範例來解釋。  </p><p>首先我們需要定義一個保存狀態的備忘錄類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Memento 備忘錄介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Memento(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; content) : content(content) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getContent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們定義發起者類別（文字編輯器），這個類別會保存當前的狀態，並且能夠建立或恢復備忘錄，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Originator 發起者類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendText</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        content += text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        content = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getText</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">save</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Memento(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="keyword">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        content = memento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>照顧者會管理這些備忘錄，但它不會直接操作它們的內容，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 照顧者類別 History</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">History</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        mementos.push_back(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mementos.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Memento(<span class="string">""</span>); <span class="comment">// 若無備忘錄可恢復，回傳空狀態</span></span><br><span class="line">        &#125;</span><br><span class="line">        Memento lastMemento = mementos.back();</span><br><span class="line">        mementos.pop_back();</span><br><span class="line">        <span class="keyword">return</span> lastMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Memento&gt; mementos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端，讓我們看看如何使用這個文字編輯器系統，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    History history;</span><br><span class="line"></span><br><span class="line">    editor.appendText(<span class="string">"123"</span>);</span><br><span class="line">    history.push(editor.save());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Text: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    editor.appendText(<span class="string">"456"</span>);</span><br><span class="line">    history.push(editor.save());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Text: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    editor.appendText(<span class="string">"789"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Text: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢復到之前的狀態</span></span><br><span class="line">    editor.restore(history.pop());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After Undo: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    editor.restore(history.pop());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After Undo: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Current Text: 123</span><br><span class="line">Current Text: 123456</span><br><span class="line">Current Text: 123456789</span><br><span class="line">After Undo: 123456</span><br><span class="line">After Undo: 123</span><br></pre></td></tr></table></figure></p><p>這個範例示範了如何使用備忘錄模式來實現文字編輯器中的復原功能。發起者（文字編輯器）負責建立和恢復備忘錄，而照顧者則管理這些狀態。  </p><h2><span id="備忘錄模式的優缺點">備忘錄模式的優缺點</span></h2><p>備忘錄模式最明顯的優點是它允許我們在不影響物件封裝的前提下保存和恢復狀態，這對於系統的靈活性和可維護性非常重要。舉例來說，文字編輯器的「復原」功能就是一個非常實用的情境，它可以讓我們安心編輯，隨時恢復先前狀態，減少操作錯誤的風險。  </p><p>備忘錄模式也有的缺點，當系統需要保存的狀態非常龐大時，備忘錄會佔用大量的記憶體，進而影響效能。尤其在大型系統中，若狀態保存頻繁，可能會導致記憶體使用量過高。  </p><h2><span id="總結">總結</span></h2><p>備忘錄模式特別適合應用於那些需要保存和恢復狀態的系統中，例如文字編輯器、遊戲或設定管理工具等。它讓我們可以在操作中放心地進行改變，隨時可以回到之前的狀態。然而我們也應該根據具體情況來決定是否使用，避免不必要的記憶體消耗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如你正在玩一個遊戲，過了一個困難的關卡，突然間手滑點錯選項，整個進度被重置，你會不會希望有個「存檔」功能讓你可以回到那個關卡？這正是備忘錄模式 Memento Pattern 可以幫助我們解決的問題。備忘錄模式讓我們可以在需要時保存某個物件的狀態，並在必要時恢復到之前的狀
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 中介者模式 Mediator Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-mediator-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-mediator-pattern/</id>
    <published>2024-09-06T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>有時候我們在開發大型系統時，會發現各個物件之間的溝通漸漸變得複雜無比，像是織了一張錯綜複雜的蜘蛛網。每個物件彼此依賴，要新增或修改功能時牽一髮而動全身。這時候中介者模式 Mediator Pattern 就像是一個「協調者」，能讓物件之間的溝通變得有條不紊，不用每個物件都互相認識。今天我們來聊聊這個神奇的模式！  </p><h2><span id="什麼是中介者模式">什麼是中介者模式？</span></h2><p>中介者模式是一種行為型設計模式，用來定義一個物件，負責協調其他多個物件之間的互動。這個模式的核心概念是：物件之間不直接溝通，而是透過一個「中介者」來傳遞訊息或協調行為。這樣做的好處是，我們可以減少物件之間的耦合度，使系統更易於維護與擴展。  </p><p>打個比方，想像你在公司裡面工作，當你需要和不同部門溝通時，不需要直接找每個部門的人，而是透過人力資源部門（HR）。HR 就是這裡的「中介者」，它負責協調你與各部門之間的溝通，讓事情變得更簡單明瞭。  </p><h2><span id="中介者模式在聊天室應用中的實例">中介者模式在聊天室應用中的實例</span></h2><p>最經典的中介者模式應用場景之一就是「聊天室」。在一個聊天室中，每個使用者都可以發訊息給其他使用者。如果沒有中介者模式，所有使用者都需要相互認識才能互相溝通，這會讓系統變得非常混亂且難以擴展。而有了中介者後，每個使用者只需要和中介者溝通，中介者再把訊息傳遞給其他相關的使用者。  </p><p>首先我們先定義中介者介面，中介者需要有一個統一的介面，定義訊息如何在物件間傳遞，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatUser</span>;</span> <span class="comment">// 前向宣告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">const</span> ChatUser* sender, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ChatRoom() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>這個具體的中介者負責管理聊天室中的使用者，並將訊息傳遞給正確的接收者，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteChatRoom</span> :</span> <span class="keyword">public</span> ChatRoom &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ChatUser*&gt; chatUsers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(ChatUser* user)</span> </span>&#123;</span><br><span class="line">        chatUsers.push_back(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">const</span> ChatUser* sender, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ChatUser* user : chatUsers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user != sender) &#123;</span><br><span class="line">                user-&gt;receive(sender-&gt;getName() + <span class="string">": "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>聊天室的使用者實作一個可以和中介者溝通的介面，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參與者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatUser</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    ChatRoom* chatRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatUser(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, ChatRoom* room) : name(name), chatRoom(room) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" 發送消息: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        chatRoom-&gt;sendMessage(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" 收到消息: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端，使用者透過中介者來發送和接收訊息，而不需要知道其他使用者的存在，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客戶端使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteChatRoom room;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ChatUser <span class="title">john</span><span class="params">(<span class="string">"John"</span>, &amp;room)</span></span>;</span><br><span class="line">    <span class="function">ChatUser <span class="title">alice</span><span class="params">(<span class="string">"Alice"</span>, &amp;room)</span></span>;</span><br><span class="line"></span><br><span class="line">    room.addUser(&amp;john);</span><br><span class="line">    room.addUser(&amp;alice);</span><br><span class="line"></span><br><span class="line">    john.send(<span class="string">"Hello, Alice!"</span>);</span><br><span class="line">    alice.send(<span class="string">"Hi, John!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">John 發送消息: Hello, Alice!</span><br><span class="line">Alice 收到消息: John: Hello, Alice!</span><br><span class="line">Alice 發送消息: Hi, John!</span><br><span class="line">John 收到消息: Alice: Hi, John!</span><br></pre></td></tr></table></figure></p><h2><span id="中介者模式的優缺點">中介者模式的優缺點</span></h2><p>中介者模式最大的優勢是「解耦」，它避免了各個物件直接互相依賴，這使得系統結構更加清晰，新增或移除物件時，不需要修改其他物件的程式碼。同時，這也讓我們可以更靈活地修改中介者的行為，達到自訂溝通規則的目的。  </p><p>中介者模式也有其潛在的缺點。隨著系統的擴展，中介者本身可能會變得非常複雜，尤其當有很多物件要透過中介者溝通時，這個中介者可能會變成一個大型的、難以維護的類別，反而會增加系統的負擔。  </p><h2><span id="總結">總結</span></h2><p>中介者模式特別適合應用於多個物件需要互相溝通的情況下，比如聊天室、事件處理系統等。透過中介者可以有效地減少物件之間的耦合，讓系統更加靈活。當然和其他設計模式一樣，我們也要根據具體的需求謹慎使用，避免讓中介者本身變得過於複雜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有時候我們在開發大型系統時，會發現各個物件之間的溝通漸漸變得複雜無比，像是織了一張錯綜複雜的蜘蛛網。每個物件彼此依賴，要新增或修改功能時牽一髮而動全身。這時候中介者模式 Mediator Pattern 就像是一個「協調者」，能讓物件之間的溝通變得有條不紊，不用每個物件都互
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 迭代器模式 Iterator Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-iterator-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-iterator-pattern/</id>
    <published>2024-09-05T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>你是否曾經面對過需要遍歷一個集合、而又不希望暴露它的內部結構的情況？這就像我們在看一本書時，並不需要知道書本是如何裝訂的，只需要翻頁就好。這時迭代器模式就派上用場了。迭代器模式提供了一種簡單且一致的方式來訪問集合中的元素，讓你不必為了遍歷資料而大費周章。  </p><h2><span id="什麼是迭代器模式">什麼是迭代器模式？</span></h2><p>迭代器模式是一種行為設計模式，它允許你逐一訪問集合物件的元素，而不需要暴露其底層的表示方式。想像你有一個儲存很多物件的容器，但你並不想揭露這些物件如何被儲存的細節。透過迭代器模式，你可以透過一個統一的界面來訪問這些元素，無論是陣列、鏈結串列還是其他資料結構，都可以輕鬆遍歷。  </p><h2><span id="迭代器模式在音樂播放清單中的應用">迭代器模式在音樂播放清單中的應用</span></h2><p>假設我們有一個音樂播放清單，這個清單內部可能是用陣列或鏈結串列來儲存歌曲，但作為使用者，你只想能夠播放下一首歌，不關心它的儲存結構。我們可以使用迭代器模式來實現這個功能。  </p><p>首先我們需要定義一個迭代器介面，這個介面會告訴使用者是否有下一首歌，並且允許他們拿到下一首歌曲，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Iterator() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們建立一個音樂清單類別，並且實作一個迭代器，這個迭代器會知道如何遍歷歌曲清單，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 音樂清單迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaylistIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; songs;</span><br><span class="line">    <span class="keyword">int</span> position;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PlaylistIterator(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; songs)</span><br><span class="line">     : songs(songs), position(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; songs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">next</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> songs[position++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音樂清單類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Playlist</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; songs;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addSong</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; song)</span> </span>&#123;</span><br><span class="line">        songs.push_back(song);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator* <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlaylistIterator(songs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端使用時，使用者不需要知道清單如何儲存歌曲，他們只需要使用迭代器提供的 <code>next()</code> 方法來依序播放，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Playlist playlist;</span><br><span class="line">    playlist.addSong(<span class="string">"Song 1"</span>);</span><br><span class="line">    playlist.addSong(<span class="string">"Song 2"</span>);</span><br><span class="line">    playlist.addSong(<span class="string">"Song 3"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator* it = playlist.createIterator();</span><br><span class="line">    <span class="keyword">while</span> (it-&gt;hasNext()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Playing: "</span> &lt;&lt; it-&gt;next() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這個例子中，我們定義了一個 <code>Iterator</code> 介面，並且在 <code>PlaylistIterator</code> 中實作了這個介面，用來遍歷歌曲清單。使用者只需要呼叫 <code>hasNext()</code> 和 <code>next()</code> 方法來逐步訪問清單中的歌曲，完全不用擔心清單的內部實現。  </p><h2><span id="迭代器模式的優缺點">迭代器模式的優缺點</span></h2><p>迭代器模式的優點在於它提供了一種統一的方式來遍歷集合，不論集合的內部結構如何變化。就像你可以用同樣的方法翻閱紙質書或電子書一樣，迭代器讓不同類型的集合能夠提供相同的操作方式。這使得程式碼變得更加靈活，因為你不需要修改訪問邏輯來適應不同的集合類型。  </p><p>迭代器模式也有一些缺點。由於每一種集合類型都需要自己的迭代器實現，這會增加一些額外的程式碼。並且在某些情況下，如果集合的大小或複雜度較大，迭代器的操作效能可能會受到影響。除此之外，記憶體管理也需要謹慎處理。  </p><h2><span id="總結">總結</span></h2><p>迭代器模式在需要遍歷複雜集合結構時非常實用，它提供了一個簡單、統一的操作介面。透過將遍歷行為封裝在迭代器中，程式設計師能夠專注於如何使用集合，而不是關心其內部細節。正如我們看書時只需專注於閱讀，不必擔心書本的裝訂一樣，迭代器模式讓操作集合變得更加直觀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是否曾經面對過需要遍歷一個集合、而又不希望暴露它的內部結構的情況？這就像我們在看一本書時，並不需要知道書本是如何裝訂的，只需要翻頁就好。這時迭代器模式就派上用場了。迭代器模式提供了一種簡單且一致的方式來訪問集合中的元素，讓你不必為了遍歷資料而大費周章。  &lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 狀態模式 State Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-state-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-state-pattern/</id>
    <published>2024-09-04T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>當你在使用某些應用程式時，是否曾經發現它們的行為會隨著某些條件或狀態的改變而改變？例如音樂播放器，當它處於「播放」狀態時去按下「播放」按鈕是沒有反應的，但當處於「暫停」狀態時，按下相同按鈕就會繼續播放音樂。這樣的設計就是狀態模式的核心概念。  </p><h2><span id="什麼是狀態模式">什麼是狀態模式？</span></h2><p>狀態模式是一種行為型設計模式，用於當物件內部狀態發生改變時，自動改變其行為。這個模式的關鍵在於將行為與狀態解耦，讓物件在不同的狀態下有不同的表現方式。換句話說，物件的行為是由當前所處的狀態決定的，而不是依賴於外部的控制邏輯。  </p><p>透過狀態模式，我們可以避免大量的 <code>if-else</code> 或 <code>switch</code> 判斷，讓程式碼更加清晰並易於擴展。  </p><h2><span id="狀態模式在音樂播放器中的應用">狀態模式在音樂播放器中的應用</span></h2><p>以音樂播放器為例，我們可以用狀態模式來處理不同的播放狀態，如「播放」、「暫停」和「停止」。每一個狀態都代表著播放器不同的行為，而狀態的切換可以由使用者操作或其他事件來驅動。  </p><p>讓我們來看看如何一步步定義這個音樂播放器的狀態系統。  </p><p>我們首先需要定義一個狀態的介面，讓不同的具體狀態類別去實現。例如，我們定義了 <code>play()</code>、<code>pause()</code> 和 <code>stop()</code> 這三個動作，每個狀態可以根據自己的邏輯來實現這些動作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向宣告，避免迴圈引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 狀態基底類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們可以定義具體的狀態類別，例如「播放中」和「暫停中」狀態。每一個具體狀態都會根據當前的情況來決定該如何處理使用者的操作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體狀態：「播放中」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayingState</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體狀態：「暫停中」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PausedState</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體狀態：「停止中」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppedState</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlayingState::play(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Already playing."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlayingState::pause(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pausing the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> PausedState()); <span class="comment">// 切換到暫停狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlayingState::stop(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> StoppedState()); <span class="comment">// 切換到停止狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PausedState::play(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resuming the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> PlayingState()); <span class="comment">// 切換回播放狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PausedState::pause(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Already paused."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PausedState::stop(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> StoppedState()); <span class="comment">// 切換到停止狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StoppedState::play(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting to play music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> PlayingState()); <span class="comment">// 切換到播放狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StoppedState::pause(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't pause. The music is stopped."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StoppedState::stop(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Already stopped."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>音樂播放器本身只需要依賴狀態物件來決定它的行為，當狀態發生變化時，播放器自動切換狀態。這樣播放器不需要自己處理具體行為，所有的行為交給不同狀態來處理，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State* state; <span class="comment">// 當前狀態</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MusicPlayer(State* initState) : state(initState) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~MusicPlayer() &#123;</span><br><span class="line">        <span class="keyword">delete</span> state; <span class="comment">// 釋放當前狀態</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(State* newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> state; <span class="comment">// 切換狀態前釋放舊狀態</span></span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state-&gt;play(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state-&gt;pause(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state-&gt;stop(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們可以在客戶端直接使用這個播放器來進行播放、暫停、停止操作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立播放器並初始化為停止狀態</span></span><br><span class="line">    <span class="function">MusicPlayer <span class="title">musicPlayer</span><span class="params">(<span class="keyword">new</span> StoppedState())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嘗試播放、暫停、停止操作</span></span><br><span class="line">    musicPlayer.play();    <span class="comment">// 開始播放</span></span><br><span class="line">    musicPlayer.pause();   <span class="comment">// 暫停播放</span></span><br><span class="line">    musicPlayer.play();    <span class="comment">// 恢復播放</span></span><br><span class="line">    musicPlayer.stop();    <span class="comment">// 停止播放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting to play music.</span><br><span class="line">Pausing the music.</span><br><span class="line">Resuming the music.</span><br><span class="line">Stopping the music.</span><br></pre></td></tr></table></figure></p><h2><span id="狀態模式的優缺點">狀態模式的優缺點</span></h2><p>狀態模式的優點是它可以讓物件的行為與其狀態緊密相關，當狀態變化時，行為也會隨之變化，這讓系統變得更加靈活且容易擴展。舉例來說，如果未來想新增「快進」狀態，我們只需定義新的 <code>FastForwardState</code> 類別，然後無需改動其他類別的邏輯。  </p><p>狀態模式的缺點在於會增加類別的數量。每個狀態都必須有一個對應的類別，這在狀態非常多的情況下，可能會讓程式變得繁瑣。另外動態切換狀態的過程中，可能會有一定的記憶體管理問題，需要小心處理。  </p><h2><span id="總結">總結</span></h2><p>狀態模式特別適合那些行為會隨著狀態改變而改變的系統。透過將狀態封裝成獨立的類別，系統可以變得更具擴展性，且更加容易維護。雖然可能會引入更多的類別和稍微複雜的結構，但它能有效地減少程式中繁瑣的判斷邏輯，讓程式碼更加清晰易懂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你在使用某些應用程式時，是否曾經發現它們的行為會隨著某些條件或狀態的改變而改變？例如音樂播放器，當它處於「播放」狀態時去按下「播放」按鈕是沒有反應的，但當處於「暫停」狀態時，按下相同按鈕就會繼續播放音樂。這樣的設計就是狀態模式的核心概念。  &lt;/p&gt;
&lt;h2&gt;&lt;span 
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 門面模式 Facade Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-facade-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-facade-pattern/</id>
    <published>2024-09-03T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>想像你剛買了一台全新的家電，同時是一台智慧家居控制中心。這台裝置可以控制家裡的燈光、空調、音響，甚至幫你泡咖啡！不過當你打開說明書，發現需要安裝十幾個不同的應用程式來單獨操控每個裝置時，這一切變得繁瑣起來。於是你會開始想如果有一個簡單的按鈕讓你輕鬆掌控所有裝置那該多好！這就是門面模式 Facade Pattern 的可以發揮的地方。門面模式讓我們可以簡化複雜系統的使用介面，將多個操作包裝成一個簡單的介面，讓使用者感到舒適和便利。  </p><h2><span id="什麼是門面模式">什麼是門面模式？</span></h2><p>門面模式是一種結構型設計模式，目的是為複雜系統提供一個簡單的介面，透過一個門面類別來隱藏系統的細節，讓使用者無需關心底層的運作方式。這個模式的核心思想就是隱藏系統的內部複雜度，對外提供一個簡單、統一的操作入口。  </p><p>具體來說，門面模式並不改變系統內部的運作邏輯，而是提供一個統一的「門面」來簡化與系統的互動。使用者只需透過這個門面進行操作，而無需了解系統內部的多個模組是如何協同工作的。  </p><h2><span id="門面模式在視訊轉換中的應用">門面模式在視訊轉換中的應用</span></h2><p>視訊轉換是一個非常複雜的過程，牽涉到解碼、轉碼、編碼、壓縮等多個步驟。假設你正在開發一個應用程式，目標是將一段視訊從一種格式轉換成另一種格式。如果讓使用者手動操作每個步驟，這對非技術背景的使用者來說無疑是個大挑戰。而門面模式非常適合這樣的應用場景。  </p><p>首先我們可以想像這個視訊轉換系統內部包含了多個模組，比如 <code>Decoder</code>、<code>Encoder</code>、<code>Compressor</code>、<code>AudioProcessor</code>、<code>SubtitleHandler</code> 和 <code>ResolutionAdjuster</code>，它們負責不同的視訊處理任務。為了讓使用者不需要關心這些細節，我們可以建立一個門面 <code>VideoConverterFacade</code>，讓這些模組協同工作。  </p><p>內部模組可能是這樣的，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; file)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Decoding "</span> &lt;&lt; file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; format)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Encoding to "</span> &lt;&lt; format &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Compressing video"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioProcessor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Processing audio..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubtitleHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addSubtitle</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; subtitleFile)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Adding subtitle: "</span> &lt;&lt; subtitleFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResolutionAdjuster</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustResolution</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Adjusting resolution to "</span> &lt;&lt; width &lt;&lt; <span class="string">"x"</span> &lt;&lt; height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們來實現門面類別，讓它來協調這些模組的工作，並提供一個簡單的操作方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoConverterFacade</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Decoder decoder;</span><br><span class="line">    Encoder encoder;</span><br><span class="line">    Compressor compressor;</span><br><span class="line">    AudioProcessor audioProcessor;</span><br><span class="line">    SubtitleHandler subtitleHandler;</span><br><span class="line">    ResolutionAdjuster resolutionAdjuster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convertVideo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; file, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; subtitleFile, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        decoder.decode(file);                      <span class="comment">// 解碼</span></span><br><span class="line">        audioProcessor.processAudio();             <span class="comment">// 處理音訊</span></span><br><span class="line">        subtitleHandler.addSubtitle(subtitleFile); <span class="comment">// 新增字幕</span></span><br><span class="line">        resolutionAdjuster.adjustResolution(width, height); <span class="comment">// 調整解析度</span></span><br><span class="line">        compressor.compress();                     <span class="comment">// 壓縮影片</span></span><br><span class="line">        encoder.encode(format);                    <span class="comment">// 編碼</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們可以在客戶端直接使用這個門面來進行視訊轉換，而無需了解內部的解碼、音訊、新增字幕、調整解析度、編碼和壓縮步驟，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VideoConverterFacade converter;</span><br><span class="line">    converter.convertVideo(<span class="string">"movie.mp4"</span>, <span class="string">"avi"</span>, <span class="string">"movie.srt"</span>, <span class="number">1920</span>, <span class="number">1080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Decoding movie.mp4</span><br><span class="line">Processing audio...</span><br><span class="line">Adding subtitle: movie.srt</span><br><span class="line">Adjusting resolution to 1920x1080</span><br><span class="line">Compressing video</span><br><span class="line">Encoding to avi</span><br></pre></td></tr></table></figure></p><p>在這個例子中，我們把多個步驟簡化成一個 <code>convertVideo</code> 方法，這讓使用者無需關心背後的具體操作，只需要指定原始檔案和目標格式即可完成任務。  </p><h2><span id="門面模式的優缺點">門面模式的優缺點</span></h2><p>門面模式的好處顯而易見，它簡化了使用者的操作體驗，讓他們不需要理解系統的複雜內部結構。這種方式提高了系統的可用性，尤其是當你有一個由多個子系統組成的複雜應用時，門面可以提供一個統一的入口，減少使用者的學習成本和操作壓力。  </p><p>同時門面模式也提升了系統的模組化，因為每個子系統依然保持相對獨立。如果需要修改內部實現或新增新功能，只需要改動子系統，門面本身不必大幅修改，這增強了系統的可擴展性。  </p><p>但門面模式也有缺點。當系統需求變得更加複雜時，門面的簡單操作可能無法滿足高階使用者的需求。他們可能希望能夠更深入地控制系統，這時門面反而可能會限制他們的靈活性。另外如果過度依賴門面來隱藏內部邏輯，可能會導致某些使用者忽視了系統真正的運作方式，導致未來難以進行細微的調整和除錯。  </p><h2><span id="總結">總結</span></h2><p>門面模式特別適合應用在那些需要隱藏系統複雜性的場景中。它透過提供一個簡單的介面，讓使用者能夠方便地與系統互動，無需深入了解內部細節。無論是在視訊轉換這樣的多步驟過程中，還是在其他複雜系統中，門面模式都能讓使用體驗更加友好且直觀。  </p><p>使用門面模式時也要權衡簡化操作與系統靈活性之間的平衡，確保系統在簡單易用的同時，也能滿足高階使用者的進階需求。畢竟簡單不代表犧牲功能，這就是門面模式所帶來的設計智慧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你剛買了一台全新的家電，同時是一台智慧家居控制中心。這台裝置可以控制家裡的燈光、空調、音響，甚至幫你泡咖啡！不過當你打開說明書，發現需要安裝十幾個不同的應用程式來單獨操控每個裝置時，這一切變得繁瑣起來。於是你會開始想如果有一個簡單的按鈕讓你輕鬆掌控所有裝置那該多好！這就
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 組合模式 Composite Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-composite-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-composite-pattern/</id>
    <published>2024-09-02T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>你有沒有遇過要同時處理單一物件與一群物件？就像在資料夾裡，你可以打開一個單獨的檔案，也可以打開一個資料夾，裡面可能包含了更多檔案或其他資料夾。這樣的層級結構看似複雜，但對使用者來說，我們希望能像操作單一檔案那樣簡單。這就是組合模式 Composite Pattern 的魔力所在，讓我們可以將單一物件與多個物件統一處理，創造出一個靈活且可擴展的層級架構。  </p><h2><span id="什麼是組合模式">什麼是組合模式？</span></h2><p>組合模式是一種結構型設計模式，它讓你能夠像處理單一物件一樣去操作物件的集合。在這個模式中，我們可以將物件組織成樹狀結構，透過將單一物件和組合物件視為同一個介面，實現對單一物件和複合物件的統一操作。  </p><p>簡單來說，組合模式解決了『如何讓樹狀結構中的物件與物件集合能被同樣對待』的問題。例如在一個UI系統中，按鈕、文字框等單一元素是葉子節點，而 Window、Panel 則是組合節點。我們希望能夠以相同的方式新增、移除和操作這些不同的元素，而不必區分它們是單一物件還是組合物件。  </p><p>組合模式通常包含以下角色：  </p><ol><li>元件（Component）：為所有具體元件和組合類定義共同的介面。  </li><li>葉節點（Leaf）：表示組合中的葉節點對象，葉節點沒有子節點。  </li><li>組合（Composite）：表示複雜元件，包含其他元件（可以是葉節點或其他複雜元件）。  </li><li>客戶端（Client）：通過元件介面與所有對象進行交互。  </li></ol><h2><span id="組合模式在圖形編輯器中的應用">組合模式在圖形編輯器中的應用</span></h2><p>讓我們來看一個圖形編輯器的例子。在圖形編輯器中，舉例：小畫家或其他類似工具，你可能會有單一的基本圖形（如圓形、矩形），也可能會有由多個基本圖形組成的複合圖形。組合模式讓我們可以使用相同的方式來操作這些基本圖形和複合圖形，無需關心它們的具體類型。  </p><p>我們先定義一個圖形的基礎介面 <code>Graphic</code>，讓所有圖形（單一圖形或組合圖形）都可以遵循相同的操作方式，例如：<code>draw</code> 跟 <code>move</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Graphic() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們來實現單一的圖形類別，比如 <code>Circle</code> 和 <code>Rectangle</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Graphic &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing Circle\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move the Circle to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Graphic &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing Rectangle\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move the Rectangle to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們實現一個組合圖形類別 <code>CompositeGraphic</code>，它可以包含多個圖形，不管是單一圖形還是其他複合圖形，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeGraphic</span> :</span> <span class="keyword">public</span> Graphic &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Graphic*&gt; graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Graphic* graphic)</span> </span>&#123;</span><br><span class="line">        graphics.push_back(graphic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; graphic : graphics) &#123;</span><br><span class="line">            graphic-&gt;draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move graphic to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">"):\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; graphic : graphics) &#123;</span><br><span class="line">            graphic-&gt;move(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在這裡我們將建立單一的圖形物件和組合的圖形物件，並使用相同的方式來操作它們，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立單一圖形</span></span><br><span class="line">    Circle circle;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立組合圖形</span></span><br><span class="line">    CompositeGraphic composite;</span><br><span class="line">    composite.add(&amp;circle);</span><br><span class="line">    composite.add(&amp;rectangle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次建立一個複合圖形並巢狀</span></span><br><span class="line">    CompositeGraphic complexComposite;</span><br><span class="line">    complexComposite.add(&amp;composite);</span><br><span class="line">    complexComposite.add(&amp;circle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 繪製所有圖形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing composite graphic:\n"</span>;</span><br><span class="line">    complexComposite.draw();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移動所有圖形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move composite graphic:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    complexComposite.move(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Drawing composite graphic:</span><br><span class="line">Drawing Circle</span><br><span class="line">Drawing Rectangle</span><br><span class="line">Drawing Circle</span><br><span class="line">Move composite graphic:</span><br><span class="line">Move graphic to (10, 20):</span><br><span class="line">Move graphic to (10, 20):</span><br><span class="line">Move the Circle to (10, 20)</span><br><span class="line">Move the Rectangle to (10, 20)</span><br><span class="line">Move the Circle to (10, 20)</span><br></pre></td></tr></table></figure></p><p>在這個例子中，<code>CompositeGraphic</code> 允許我們將單一圖形和其他組合圖形一起處理，無需區分它們是單一圖形還是由多個圖形組成的組合。這樣一來整個圖形編輯器的結構變得更加靈活，讓我們能夠輕鬆管理複雜的圖形組合。  </p><h2><span id="組合模式的優缺點">組合模式的優缺點</span></h2><p>組合模式的最大優勢在於它讓系統結構更加簡單和靈活。無論我們處理的是單一物件還是複合物件，都可以使用同樣的介面，這降低了處理不同類型物件時的複雜性。另外組合模式讓我們可以輕鬆地擴展系統，只需新增更多類型的物件或組合物件，而不必修改現有的程式碼。  </p><p>組合模式也帶來了額外的設計複雜度。當我們的物件結構變得非常複雜時，理解和管理這些層級可能會變得困難。此外對於只需要處理單一物件的情況來說，組合模式的額外靈活性可能是多餘的，反而會增加系統的負擔。  </p><h2><span id="總結">總結</span></h2><p>組合模式讓我們能夠用統一的方式處理單一物件和複合物件。它廣泛應用於各種層級結構中，例如圖形編輯器、檔案系統、UI 元素等。雖然這個模式能夠簡化對複雜物件結構的處理，但它也可能帶來一些設計上的挑戰，因此在使用時需要謹慎考量其適用性。  </p><p>當你下次面對需要同時處理單一和多個物件的情況時，組合模式可能正是解決問題的鑰匙。無論是單一物件還是複合物件，最終它們都應該能夠被簡單而一致地操作，這就是組合模式的魅力所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你有沒有遇過要同時處理單一物件與一群物件？就像在資料夾裡，你可以打開一個單獨的檔案，也可以打開一個資料夾，裡面可能包含了更多檔案或其他資料夾。這樣的層級結構看似複雜，但對使用者來說，我們希望能像操作單一檔案那樣簡單。這就是組合模式 Composite Pattern 的魔力
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 轉接器模式 Adapter Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-adapter-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-adapter-pattern/</id>
    <published>2024-09-01T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>當你旅行時，面對世界各地形形色色的插座，每個國家的插座形狀和電壓都可能不一樣，而你只帶了一台手機充電器。如果沒有一個合適的插頭轉接器，你的電子裝置將無法使用，例如台灣手機充電器帶去歐洲不能直接使用，接上了轉接頭就可以使用了。這個轉接器的角色就像是軟體開發中的轉接器模式 Adapter Pattern。在軟體開發中，我們經常需要整合不同的系統或使用第三方函式庫。但有時這些系統或函式庫的介面與我們的程式碼不相容。轉接器模式它的功能在於讓兩個原本不相容的介面協同工作，讓你可以在不更改既有程式碼的情況下，輕鬆地整合不同的系統或類別。  </p><h2><span id="什麼是轉接器模式">什麼是轉接器模式？</span></h2><p>轉接器模式是一種結構型設計模式，它將原本介面不相容而不能一起工作的類能夠協同工作。簡單來說，轉接器就像是一個轉換器，將一個類的介面轉換成客戶端所期望的另一種介面。  </p><p>這種模式讓原本不相容的類可以一起工作，而無需修改它們的原始碼。它在我們需要使用一個現有的類，但是其介面與我們的需求不匹配時特別有用。  </p><p>轉接器模式通常用於解決因現有程式碼無法修改或類別不相容而導致的整合問題。加入轉接器後，我們可以在不更改既有類別的情況下，實現介面的一致性，達到程式碼的複用性和擴展性。  </p><p>轉接器模式通常包含以下角色：  </p><ol><li>目標介面（Target）：客戶端所期望的介面。  </li><li>轉接者（Adaptee）：需要被轉接的類，它有著不相容的介面。  </li><li>轉接器（Adapter）：將轉接者的介面轉換為目標介面的類別。  </li></ol><h2><span id="轉接器模式在json到xml轉換中的應用">轉接器模式在JSON到XML轉換中的應用</span></h2><p>讓我們用一個例子來理解轉接器模式：JSON到XML的資料格式轉換。  </p><p>假設你正在開發一個系統，這個系統需要處理XML格式的資料。但是你發現有一個非常好用的第三方函式庫，可以提供你所需的所有資料，唯一的問題是這個函式庫輸出的是JSON格式。這時就可以使用轉接器模式幫助我們解決這個問題。  </p><p>讓我們用程式碼來模擬這個場景：  </p><p>首先我們定義目標介面（XML資料提供者），<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLData</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getXMLData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們有一個現有的類（JSON資料提供者），它的介面與目標介面不相容，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONData</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getJSONData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"name\": \"John\", \"age\": 30&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們建立一個轉接器類，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONToXMLAdapter</span> :</span> <span class="keyword">public</span> XMLData &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    JSONData* jsonData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JSONToXMLAdapter(JSONData* data) : jsonData(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getXMLData</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> jsonData = <span class="keyword">this</span>-&gt;jsonData-&gt;getJSONData();</span><br><span class="line">        <span class="comment">// 實際的JSON到XML的轉換邏輯</span></span><br><span class="line">        <span class="comment">// 為了簡化，我們只做一個模擬的轉換</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> xmlData = <span class="string">"&lt;person&gt;&lt;name&gt;John&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;&lt;/person&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> xmlData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後客戶端（使用者）可以這樣使用，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONData* jsonData = <span class="keyword">new</span> JSONData();</span><br><span class="line">    XMLData* xmlData = <span class="keyword">new</span> JSONToXMLAdapter(jsonData);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"XML Data: "</span> &lt;&lt; xmlData-&gt;getXMLData() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> xmlData;</span><br><span class="line">    <span class="keyword">delete</span> jsonData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這個例子中，<code>JSONToXMLAdapter</code> 類扮演了轉接器的角色。它實現了 <code>XMLData</code> 介面，同時內部持有一個 <code>JSONData</code> 物件。當呼叫 <code>getXMLData()</code> 方法時，轉接器會先取得JSON資料，然後將其轉換為XML格式，從而實現了從JSON到XML的轉換。  </p><h2><span id="轉接器模式的優缺點">轉接器模式的優缺點</span></h2><p>轉接器模式的一個顯著優點是，透過使用轉接器我們可以讓原本不相容的系統或類別協同工作，而無需修改它們的原始程式碼。這在處理第三方庫或舊系統時特別有用，因為我們通常無法直接修改這些程式碼。另外轉接器模式還遵循了開放封閉原則，允許我們引入新的轉接器而不會破壞現有的程式碼。  </p><p>轉接器模式也有缺點。它增加了系統的複雜性，因為引入了新的類和介面。在某些情況下，過度使用轉接器可能會導致程式碼難以理解和維護。由於轉接器模式涉及到不同類別介面之間的轉換，這可能會導致一些性能開銷，特別是在大型應用中，頻繁的介面轉換可能會對系統的效能產生影響，因為它在原介面和目標介面之間增加了一個間接層。  </p><h2><span id="總結">總結</span></h2><p>轉接器模式是一種強大的工具，讓我們可以輕鬆地解決系統整合和類別不相容的問題。透過這種模式我們能夠在不改變既有程式碼的前提下，加入新功能或整合外部系統，從而提高系統的靈活性和可擴展性。然而在使用轉接器模式時，也需要考慮到其可能帶來的效能消耗和程式碼複雜性問題。但在許多情況下，轉接器模式帶來的靈活性和複用性遠遠超過了這些小缺點。作為一個優秀的軟體工程師，了解並正確使用轉接器模式可以幫助你更好地處理現實世界中的各種介面不相容問題。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你旅行時，面對世界各地形形色色的插座，每個國家的插座形狀和電壓都可能不一樣，而你只帶了一台手機充電器。如果沒有一個合適的插頭轉接器，你的電子裝置將無法使用，例如台灣手機充電器帶去歐洲不能直接使用，接上了轉接頭就可以使用了。這個轉接器的角色就像是軟體開發中的轉接器模式 Ad
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 建造者模式 Builder Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-builder-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-builder-pattern/</id>
    <published>2024-08-31T12:00:00.000Z</published>
    <updated>2024-09-15T23:30:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>當你進入餐廳點餐時，菜單上琳瑯滿目的選擇可能讓你感到無從下手。你可以選擇一個套餐，但如果你有特別的需求，例如多點一份沙拉，少放一點醬料，這時候就需要進行個性化的訂單。而這樣的流程，正是建造者模式 Builder Pattern 的精髓所在。它不僅在生活中隨處可見，在軟體設計中更是強大而實用的一種模式。  </p><h2><span id="什麼是建造者模式">什麼是建造者模式？</span></h2><p>建造者模式是一種建立型設計模式，它將物件的建立過程分解為多個步驟，並且可以根據需求有選擇地組合這些步驟，最終產生我們所需的物件。這樣的設計模式特別適合用於那些需要一步步構建，且每一步可能有不同選擇的複雜物件。  </p><p>建造者模式通常包含以下角色：  </p><ol><li>Product（產品）：最終被構建的複雜物件。  </li><li>Builder（建造者）：定義構建物件的抽象介面。  </li><li>ConcreteBuilder（具體建造者）：實現 Builder 介面，提供具體的構建步驟。  </li><li>Director（指揮者）：負責使用建造者來構建產品，控制建造的過程。  </li></ol><h2><span id="建造者模式在訂製汽車中的應用">建造者模式在訂製汽車中的應用</span></h2><p>讓我們以訂製汽車為例來說明建造者模式的應用。想像你正在購買一輛新車，經銷商會給你提供一系列選項，從引擎、輪胎到內裝，你可以自由選擇搭配，打造一輛專屬於你的車輛。這正是建造者模式最典型的應用場景。  </p><p>我們需要定義最終要建造的產品 <code>Car</code> 類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 產品類 Product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> engine;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> wheels;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> interior;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; engineType)</span> </span>&#123;</span><br><span class="line">        engine = engineType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWheels</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; wheelType)</span> </span>&#123;</span><br><span class="line">        wheels = wheelType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInterior</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; interiorType)</span> </span>&#123;</span><br><span class="line">        interior = interiorType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSpecifications</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Engine: "</span> &lt;&lt; engine &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">                  &lt;&lt; <span class="string">"Wheels: "</span> &lt;&lt; wheels &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">                  &lt;&lt; <span class="string">"Interior: "</span> &lt;&lt; interior &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再定義一個 <code>Builder</code> 介面，它包含了構建汽車各部分的方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者介面 Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildWheels</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildInterior</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">getCar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~CarBuilder() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們建立具體的建造者類別，例如一個豪華汽車的建造者，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體建造者 ConcreteBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuxuryCarBuilder</span> :</span> <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car* car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LuxuryCarBuilder() &#123;</span><br><span class="line">        car = <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildEngine</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        car-&gt;setEngine(<span class="string">"V8 Turbo Engine"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildWheels</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        car-&gt;setWheels(<span class="string">"Alloy Wheels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildInterior</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        car-&gt;setInterior(<span class="string">"Leather Interior"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car* <span class="title">getCar</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們建立一個指揮者來控制建造的過程，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指揮者 Director</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarDirector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CarBuilder* builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CarDirector(CarBuilder* builder) : builder(builder) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car* <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder-&gt;buildEngine();</span><br><span class="line">        builder-&gt;buildWheels();</span><br><span class="line">        builder-&gt;buildInterior();</span><br><span class="line">        <span class="keyword">return</span> builder-&gt;getCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>當你需要訂製一輛豪華汽車時，只需透過建造者模式來構建它，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CarBuilder* builder = <span class="keyword">new</span> LuxuryCarBuilder();</span><br><span class="line">    <span class="function">CarDirector <span class="title">director</span><span class="params">(builder)</span></span>;</span><br><span class="line">    Car* car = director.construct();</span><br><span class="line"></span><br><span class="line">    car-&gt;showSpecifications();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> car;</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這樣的設計讓我們可以輕鬆地改變汽車的設定，或者在需要時引入新的建造者，而不必修改現有的邏輯。建造者模式提供了靈活的物件構建過程，使得我們可以在不同需求下產生不同的產品。  </p><h2><span id="建造者模式的優缺點">建造者模式的優缺點</span></h2><p>建造者模式的優點在於它的靈活性和可擴展性。由於構建過程是分步驟進行的，我們可以輕鬆地在不同的情境下進行客製化，無論是增加新功能還是修改現有步驟，都不會影響整個系統的設計。這樣的設計模式特別適合那些物件結構複雜且需要逐步構建的場景。  </p><p>建造者模式也有缺點。由於每一個具體建造者都必須實現所有的建造步驟，這會導致大量的程式碼重複，特別是在類似的建造者之間。並且當物件的構建步驟過多時，可能會使得建造者變得臃腫，降低了程式碼的可讀性與維護性。另外指揮者雖然讓建造過程更具組織性，但也可能產生額外的複雜度。  </p><h2><span id="總結">總結</span></h2><p>建造者模式特別適合於建立複雜物件或者需要靈活設定的物件。它就像是一個精密的工廠流水線，可以根據不同的需求生產出不同的產品，而且每個產品都保持品質與一致性。在現代軟體開發中，無論是複雜的汽車製造、蓋房屋，還是表單產生器，建造者模式都能幫助我們應對，當你下次面對需要建立複雜物件，或者需要根據不同情況建立不同類型物件的場景時，不妨考慮使用建造者模式。它可能正是你解決問題的關鍵。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你進入餐廳點餐時，菜單上琳瑯滿目的選擇可能讓你感到無從下手。你可以選擇一個套餐，但如果你有特別的需求，例如多點一份沙拉，少放一點醬料，這時候就需要進行個性化的訂單。而這樣的流程，正是建造者模式 Builder Pattern 的精髓所在。它不僅在生活中隨處可見，在軟體設計
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模式" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>

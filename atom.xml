<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShengYu Talk</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shengyu7697.github.io/"/>
  <updated>2024-09-11T00:10:07.594Z</updated>
  <id>https://shengyu7697.github.io/</id>
  
  <author>
    <name>ShengYu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 設計模式 - 責任鏈模式 Chain of Responsibility Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-chain-of-responsibility-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-chain-of-responsibility-pattern/</id>
    <published>2024-09-08T12:00:00.000Z</published>
    <updated>2024-09-11T00:10:07.594Z</updated>
    
    <content type="html"><![CDATA[<p>想像你在公司工作，遇到一個問題，你先向主管反映，如果主管無法解決，再往上報告給更高層級的主管，直到有人能解決問題。這就是「責任鏈模式」的核心概念。這種模式允許你把任務逐層傳遞，直到某個物件可以處理它。在軟體設計中，這可以讓系統更加靈活，避免固定的條件判斷，提升維護性。  </p><h2><span id="什麼是責任鏈模式">什麼是責任鏈模式？</span></h2><p>責任鏈模式是一種行為型設計模式，允許多個物件按順序處理請求。每個物件有機會決定是否處理請求，或者將其轉交給下一個物件。這樣一來我們可以將不同的職責模組化，讓每個物件專注於自己的職責範圍，而不用關心整個處理流程。  </p><p>想像你正在玩一個熱門的多人線上遊戲。當你遇到問題需要幫助時，你可能會先詢問遊戲內的自動客服系統。如果自動客服無法解決，問題會被轉到人工客服。如果人工客服也無法處理，問題可能會被上報給技術支援團隊。這就是一個典型的責任鏈模式應用場景。  </p><h2><span id="責任鏈模式在客戶支援系統中的應用">責任鏈模式在客戶支援系統中的應用</span></h2><p>一個常見的應用例子是客戶支援系統，當客戶送出問題時，問題可能由多個不同層級的支援人員來處理：自動客服、人工客服、技術支援團隊等。每個層級都會檢查問題，如果無法解決，就會向上級遞交，直到問題被解決。  </p><p>首先我們定義一個抽象的處理者類，每個 Handler（如客服）都有一個處理請求的方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 處理者 Handler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CustomerServiceHandler* nextHandler;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~CustomerServiceHandler() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(CustomerServiceHandler* handler)</span> </span>&#123;</span><br><span class="line">        nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們實現具體的處理者類，具體的 Handler 如自動客服、人工客服和技術支援團隊繼承這個介面，並實現處理方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體處理者 Concrete Handlers</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomatedSystem</span> :</span> <span class="keyword">public</span> CustomerServiceHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="string">"簡單問題"</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"自動系統：我可以回答這個簡單問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanAgent</span> :</span> <span class="keyword">public</span> CustomerServiceHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="string">"複雜問題"</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"人工客服：我來處理這個複雜問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TechnicalSupport</span> :</span> <span class="keyword">public</span> CustomerServiceHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; request)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="string">"技術問題"</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"技術支持：我們會深入研究並解決這個問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;handleRequest(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"無法解決這個問題。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後客戶端可以這樣使用，當客戶發出請求時，系統會從自動客服開始，如果無法處理，請求會傳遞到下一個層級，直到問題解決，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立三個處理者</span></span><br><span class="line">    AutomatedSystem* autoSystem = <span class="keyword">new</span> AutomatedSystem();</span><br><span class="line">    HumanAgent* humanAgent = <span class="keyword">new</span> HumanAgent();</span><br><span class="line">    TechnicalSupport* techSupport = <span class="keyword">new</span> TechnicalSupport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 設定責任鏈</span></span><br><span class="line">    autoSystem-&gt;setNext(humanAgent);</span><br><span class="line">    humanAgent-&gt;setNext(techSupport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 測試不同請求</span></span><br><span class="line">    autoSystem-&gt;handleRequest(<span class="string">"簡單問題"</span>);</span><br><span class="line">    autoSystem-&gt;handleRequest(<span class="string">"複雜問題"</span>);</span><br><span class="line">    autoSystem-&gt;handleRequest(<span class="string">"技術問題"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> autoSystem;</span><br><span class="line">    <span class="keyword">delete</span> humanAgent;</span><br><span class="line">    <span class="keyword">delete</span> techSupport;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自動系統：我可以回答這個簡單問題。</span><br><span class="line">人工客服：我來處理這個複雜問題。</span><br><span class="line">技術支持：我們會深入研究並解決這個問題。</span><br></pre></td></tr></table></figure></p><h2><span id="責任鏈模式的優缺點">責任鏈模式的優缺點</span></h2><p>責任鏈模式的一大優點是它讓系統更加靈活。新增一個 Handler 不需要修改其他 Handler 的程式碼，只需要在責任鏈中插入新的 Handler 即可，這極大地提高了擴展性。同時 Handler 之間的耦合度降低，每個 Handler 只專注於自己能解決的問題。  </p><p>然而這個模式也有一些的缺點。如果鏈條過長請求可能會經過很多 Handler ，增加了系統的處理時間。此外如果沒有適當的終止條件，請求可能會在處理鏈中無限傳遞。  </p><h2><span id="總結">總結</span></h2><p>責任鏈模式讓我們能夠將職責分散到不同的 Handler 中，提升了系統的可擴展性和維護性。在某些需要多層處理的場景，像是客戶支援系統或是事件處理系統中，這是一種非常有效的解決方案。這個模式避免了一堆 <code>if-else</code> 的條件判斷，讓系統更靈活但也需要注意過長的處理鏈條可能帶來的效率問題。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你在公司工作，遇到一個問題，你先向主管反映，如果主管無法解決，再往上報告給更高層級的主管，直到有人能解決問題。這就是「責任鏈模式」的核心概念。這種模式允許你把任務逐層傳遞，直到某個物件可以處理它。在軟體設計中，這可以讓系統更加靈活，避免固定的條件判斷，提升維護性。  &lt;
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 備忘錄模式 Memento Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-memento-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-memento-pattern/</id>
    <published>2024-09-07T12:00:00.000Z</published>
    <updated>2024-09-10T13:40:07.179Z</updated>
    
    <content type="html"><![CDATA[<p>假如你正在玩一個遊戲，過了一個困難的關卡，突然間手滑點錯選項，整個進度被重置，你會不會希望有個「存檔」功能讓你可以回到那個關卡？這正是備忘錄模式 Memento Pattern 可以幫助我們解決的問題。備忘錄模式讓我們可以在需要時保存某個物件的狀態，並在必要時恢復到之前的狀態，像是一個系統的「後悔藥」。  </p><h2><span id="什麼是備忘錄模式">什麼是備忘錄模式？</span></h2><p>備忘錄模式是一種行為型設計模式，用來保存物件的狀態，這樣就可以在未來的某個時刻還原這些狀態。這個模式提供了一個方法讓物件能夠保存自己的狀態，並且在不違反封裝原則的情況下將其恢復。備忘錄模式可以想像成一個「快照」，讓我們可以回到某個特定的時間點，而不用擔心破壞系統的其他部分。  </p><p>這個模式的基本角色包括：  </p><ol><li>Originator（發起者）：擁有狀態並可以建立或恢復備忘錄。  </li><li>Memento（備忘錄）：保存Originator的內部狀態，並且只有Originator可以訪問它。  </li><li>Caretaker（照顧者）：負責管理備忘錄，但不會修改其內容，只會在需要時請求Originator恢復狀態。  </li></ol><h2><span id="備忘錄模式在文字編輯器中的應用">備忘錄模式在文字編輯器中的應用</span></h2><p>一個很常見的應用例子就是文字編輯器中的「復原」與「重做」功能。當你編輯檔案時，每一次的修改都可以被記錄下來，這樣當你需要復原時，可以回到先前的狀態。讓我們用一個簡單的C++範例來解釋。  </p><p>首先我們需要定義一個保存狀態的備忘錄類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Memento 備忘錄介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Memento(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; content) : content(content) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getContent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們定義發起者類別（文字編輯器），這個類別會保存當前的狀態，並且能夠建立或恢復備忘錄，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Originator 發起者類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendText</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        content += text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        content = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getText</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">save</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Memento(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="keyword">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        content = memento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>照顧者會管理這些備忘錄，但它不會直接操作它們的內容，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 照顧者類別 History</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">History</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        mementos.push_back(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mementos.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Memento(<span class="string">""</span>); <span class="comment">// 若無備忘錄可恢復，回傳空狀態</span></span><br><span class="line">        &#125;</span><br><span class="line">        Memento lastMemento = mementos.back();</span><br><span class="line">        mementos.pop_back();</span><br><span class="line">        <span class="keyword">return</span> lastMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Memento&gt; mementos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端，讓我們看看如何使用這個文字編輯器系統，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    History history;</span><br><span class="line"></span><br><span class="line">    editor.appendText(<span class="string">"123"</span>);</span><br><span class="line">    history.push(editor.save());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Text: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    editor.appendText(<span class="string">"456"</span>);</span><br><span class="line">    history.push(editor.save());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Text: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    editor.appendText(<span class="string">"789"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Text: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢復到之前的狀態</span></span><br><span class="line">    editor.restore(history.pop());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After Undo: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    editor.restore(history.pop());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After Undo: "</span> &lt;&lt; editor.getText() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Current Text: 123</span><br><span class="line">Current Text: 123456</span><br><span class="line">Current Text: 123456789</span><br><span class="line">After Undo: 123456</span><br><span class="line">After Undo: 123</span><br></pre></td></tr></table></figure></p><p>這個範例示範了如何使用備忘錄模式來實現文字編輯器中的復原功能。發起者（文字編輯器）負責建立和恢復備忘錄，而照顧者則管理這些狀態。  </p><h2><span id="備忘錄模式的優缺點">備忘錄模式的優缺點</span></h2><p>備忘錄模式最明顯的優點是它允許我們在不影響物件封裝的前提下保存和恢復狀態，這對於系統的靈活性和可維護性非常重要。舉例來說，文字編輯器的「復原」功能就是一個非常實用的情境，它可以讓我們安心編輯，隨時恢復先前狀態，減少操作錯誤的風險。  </p><p>備忘錄模式也有的缺點，當系統需要保存的狀態非常龐大時，備忘錄會佔用大量的記憶體，進而影響效能。尤其在大型系統中，若狀態保存頻繁，可能會導致記憶體使用量過高。  </p><h2><span id="總結">總結</span></h2><p>備忘錄模式特別適合應用於那些需要保存和恢復狀態的系統中，例如文字編輯器、遊戲或設定管理工具等。它讓我們可以在操作中放心地進行改變，隨時可以回到之前的狀態。然而我們也應該根據具體情況來決定是否使用，避免不必要的記憶體消耗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如你正在玩一個遊戲，過了一個困難的關卡，突然間手滑點錯選項，整個進度被重置，你會不會希望有個「存檔」功能讓你可以回到那個關卡？這正是備忘錄模式 Memento Pattern 可以幫助我們解決的問題。備忘錄模式讓我們可以在需要時保存某個物件的狀態，並在必要時恢復到之前的狀
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 中介者模式 Mediator Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-mediator-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-mediator-pattern/</id>
    <published>2024-09-06T12:00:00.000Z</published>
    <updated>2024-09-09T14:40:06.187Z</updated>
    
    <content type="html"><![CDATA[<p>有時候我們在開發大型系統時，會發現各個物件之間的溝通漸漸變得複雜無比，像是織了一張錯綜複雜的蜘蛛網。每個物件彼此依賴，要新增或修改功能時牽一髮而動全身。這時候中介者模式 Mediator Pattern 就像是一個「協調者」，能讓物件之間的溝通變得有條不紊，不用每個物件都互相認識。今天我們來聊聊這個神奇的模式！  </p><h2><span id="什麼是中介者模式">什麼是中介者模式？</span></h2><p>中介者模式是一種行為型設計模式，用來定義一個物件，負責協調其他多個物件之間的互動。這個模式的核心概念是：物件之間不直接溝通，而是透過一個「中介者」來傳遞訊息或協調行為。這樣做的好處是，我們可以減少物件之間的耦合度，使系統更易於維護與擴展。  </p><p>打個比方，想像你在公司裡面工作，當你需要和不同部門溝通時，不需要直接找每個部門的人，而是透過人力資源部門（HR）。HR 就是這裡的「中介者」，它負責協調你與各部門之間的溝通，讓事情變得更簡單明瞭。  </p><h2><span id="中介者模式在聊天室應用中的實例">中介者模式在聊天室應用中的實例</span></h2><p>最經典的中介者模式應用場景之一就是「聊天室」。在一個聊天室中，每個使用者都可以發訊息給其他使用者。如果沒有中介者模式，所有使用者都需要相互認識才能互相溝通，這會讓系統變得非常混亂且難以擴展。而有了中介者後，每個使用者只需要和中介者溝通，中介者再把訊息傳遞給其他相關的使用者。  </p><p>首先我們先定義中介者介面，中介者需要有一個統一的介面，定義訊息如何在物件間傳遞，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatUser</span>;</span> <span class="comment">// 前向宣告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">const</span> ChatUser* sender, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ChatRoom() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>這個具體的中介者負責管理聊天室中的使用者，並將訊息傳遞給正確的接收者，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteChatRoom</span> :</span> <span class="keyword">public</span> ChatRoom &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ChatUser*&gt; chatUsers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(ChatUser* user)</span> </span>&#123;</span><br><span class="line">        chatUsers.push_back(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">const</span> ChatUser* sender, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ChatUser* user : chatUsers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user != sender) &#123;</span><br><span class="line">                user-&gt;receive(sender-&gt;getName() + <span class="string">": "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>聊天室的使用者實作一個可以和中介者溝通的介面，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參與者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatUser</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    ChatRoom* chatRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatUser(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, ChatRoom* room) : name(name), chatRoom(room) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" 發送消息: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        chatRoom-&gt;sendMessage(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" 收到消息: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端，使用者透過中介者來發送和接收訊息，而不需要知道其他使用者的存在，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客戶端使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteChatRoom room;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ChatUser <span class="title">john</span><span class="params">(<span class="string">"John"</span>, &amp;room)</span></span>;</span><br><span class="line">    <span class="function">ChatUser <span class="title">alice</span><span class="params">(<span class="string">"Alice"</span>, &amp;room)</span></span>;</span><br><span class="line"></span><br><span class="line">    room.addUser(&amp;john);</span><br><span class="line">    room.addUser(&amp;alice);</span><br><span class="line"></span><br><span class="line">    john.send(<span class="string">"Hello, Alice!"</span>);</span><br><span class="line">    alice.send(<span class="string">"Hi, John!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">John 發送消息: Hello, Alice!</span><br><span class="line">Alice 收到消息: John: Hello, Alice!</span><br><span class="line">Alice 發送消息: Hi, John!</span><br><span class="line">John 收到消息: Alice: Hi, John!</span><br></pre></td></tr></table></figure></p><h2><span id="中介者模式的優缺點">中介者模式的優缺點</span></h2><p>中介者模式最大的優勢是「解耦」，它避免了各個物件直接互相依賴，這使得系統結構更加清晰，新增或移除物件時，不需要修改其他物件的程式碼。同時，這也讓我們可以更靈活地修改中介者的行為，達到自訂溝通規則的目的。  </p><p>中介者模式也有其潛在的缺點。隨著系統的擴展，中介者本身可能會變得非常複雜，尤其當有很多物件要透過中介者溝通時，這個中介者可能會變成一個大型的、難以維護的類別，反而會增加系統的負擔。  </p><h2><span id="總結">總結</span></h2><p>中介者模式特別適合應用於多個物件需要互相溝通的情況下，比如聊天室、事件處理系統等。透過中介者可以有效地減少物件之間的耦合，讓系統更加靈活。當然和其他設計模式一樣，我們也要根據具體的需求謹慎使用，避免讓中介者本身變得過於複雜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有時候我們在開發大型系統時，會發現各個物件之間的溝通漸漸變得複雜無比，像是織了一張錯綜複雜的蜘蛛網。每個物件彼此依賴，要新增或修改功能時牽一髮而動全身。這時候中介者模式 Mediator Pattern 就像是一個「協調者」，能讓物件之間的溝通變得有條不紊，不用每個物件都互
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 迭代器模式 Iterator Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-iterator-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-iterator-pattern/</id>
    <published>2024-09-05T12:00:00.000Z</published>
    <updated>2024-09-08T01:00:07.476Z</updated>
    
    <content type="html"><![CDATA[<p>你是否曾經面對過需要遍歷一個集合、而又不希望暴露它的內部結構的情況？這就像我們在看一本書時，並不需要知道書本是如何裝訂的，只需要翻頁就好。這時迭代器模式就派上用場了。迭代器模式提供了一種簡單且一致的方式來訪問集合中的元素，讓你不必為了遍歷資料而大費周章。  </p><h2><span id="什麼是迭代器模式">什麼是迭代器模式？</span></h2><p>迭代器模式是一種行為設計模式，它允許你逐一訪問集合物件的元素，而不需要暴露其底層的表示方式。想像你有一個儲存很多物件的容器，但你並不想揭露這些物件如何被儲存的細節。透過迭代器模式，你可以透過一個統一的界面來訪問這些元素，無論是陣列、鏈結串列還是其他資料結構，都可以輕鬆遍歷。  </p><h2><span id="迭代器模式在音樂播放清單中的應用">迭代器模式在音樂播放清單中的應用</span></h2><p>假設我們有一個音樂播放清單，這個清單內部可能是用陣列或鏈結串列來儲存歌曲，但作為使用者，你只想能夠播放下一首歌，不關心它的儲存結構。我們可以使用迭代器模式來實現這個功能。  </p><p>首先我們需要定義一個迭代器介面，這個介面會告訴使用者是否有下一首歌，並且允許他們拿到下一首歌曲，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Iterator() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們建立一個音樂清單類別，並且實作一個迭代器，這個迭代器會知道如何遍歷歌曲清單，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 音樂清單迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaylistIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; songs;</span><br><span class="line">    <span class="keyword">int</span> position;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PlaylistIterator(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; songs)</span><br><span class="line">     : songs(songs), position(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; songs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">next</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> songs[position++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音樂清單類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Playlist</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; songs;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addSong</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; song)</span> </span>&#123;</span><br><span class="line">        songs.push_back(song);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator* <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlaylistIterator(songs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端使用時，使用者不需要知道清單如何儲存歌曲，他們只需要使用迭代器提供的 <code>next()</code> 方法來依序播放，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Playlist playlist;</span><br><span class="line">    playlist.addSong(<span class="string">"Song 1"</span>);</span><br><span class="line">    playlist.addSong(<span class="string">"Song 2"</span>);</span><br><span class="line">    playlist.addSong(<span class="string">"Song 3"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator* it = playlist.createIterator();</span><br><span class="line">    <span class="keyword">while</span> (it-&gt;hasNext()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Playing: "</span> &lt;&lt; it-&gt;next() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這個例子中，我們定義了一個 <code>Iterator</code> 介面，並且在 <code>PlaylistIterator</code> 中實作了這個介面，用來遍歷歌曲清單。使用者只需要呼叫 <code>hasNext()</code> 和 <code>next()</code> 方法來逐步訪問清單中的歌曲，完全不用擔心清單的內部實現。  </p><h2><span id="迭代器模式的優缺點">迭代器模式的優缺點</span></h2><p>迭代器模式的優點在於它提供了一種統一的方式來遍歷集合，不論集合的內部結構如何變化。就像你可以用同樣的方法翻閱紙質書或電子書一樣，迭代器讓不同類型的集合能夠提供相同的操作方式。這使得程式碼變得更加靈活，因為你不需要修改訪問邏輯來適應不同的集合類型。  </p><p>迭代器模式也有一些缺點。由於每一種集合類型都需要自己的迭代器實現，這會增加一些額外的程式碼。並且在某些情況下，如果集合的大小或複雜度較大，迭代器的操作效能可能會受到影響。除此之外，記憶體管理也需要謹慎處理。  </p><h2><span id="總結">總結</span></h2><p>迭代器模式在需要遍歷複雜集合結構時非常實用，它提供了一個簡單、統一的操作介面。透過將遍歷行為封裝在迭代器中，程式設計師能夠專注於如何使用集合，而不是關心其內部細節。正如我們看書時只需專注於閱讀，不必擔心書本的裝訂一樣，迭代器模式讓操作集合變得更加直觀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是否曾經面對過需要遍歷一個集合、而又不希望暴露它的內部結構的情況？這就像我們在看一本書時，並不需要知道書本是如何裝訂的，只需要翻頁就好。這時迭代器模式就派上用場了。迭代器模式提供了一種簡單且一致的方式來訪問集合中的元素，讓你不必為了遍歷資料而大費周章。  &lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 狀態模式 State Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-state-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-state-pattern/</id>
    <published>2024-09-04T12:00:00.000Z</published>
    <updated>2024-09-07T10:30:06.190Z</updated>
    
    <content type="html"><![CDATA[<p>當你在使用某些應用程式時，是否曾經發現它們的行為會隨著某些條件或狀態的改變而改變？例如音樂播放器，當它處於「播放」狀態時去按下「播放」按鈕是沒有反應的，但當處於「暫停」狀態時，按下相同按鈕就會繼續播放音樂。這樣的設計就是狀態模式的核心概念。  </p><h2><span id="什麼是狀態模式">什麼是狀態模式？</span></h2><p>狀態模式是一種行為型設計模式，用於當物件內部狀態發生改變時，自動改變其行為。這個模式的關鍵在於將行為與狀態解耦，讓物件在不同的狀態下有不同的表現方式。換句話說，物件的行為是由當前所處的狀態決定的，而不是依賴於外部的控制邏輯。  </p><p>透過狀態模式，我們可以避免大量的 <code>if-else</code> 或 <code>switch</code> 判斷，讓程式碼更加清晰並易於擴展。  </p><h2><span id="狀態模式在音樂播放器中的應用">狀態模式在音樂播放器中的應用</span></h2><p>以音樂播放器為例，我們可以用狀態模式來處理不同的播放狀態，如「播放」、「暫停」和「停止」。每一個狀態都代表著播放器不同的行為，而狀態的切換可以由使用者操作或其他事件來驅動。  </p><p>讓我們來看看如何一步步定義這個音樂播放器的狀態系統。  </p><p>我們首先需要定義一個狀態的介面，讓不同的具體狀態類別去實現。例如，我們定義了 <code>play()</code>、<code>pause()</code> 和 <code>stop()</code> 這三個動作，每個狀態可以根據自己的邏輯來實現這些動作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向宣告，避免迴圈引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 狀態基底類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們可以定義具體的狀態類別，例如「播放中」和「暫停中」狀態。每一個具體狀態都會根據當前的情況來決定該如何處理使用者的操作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體狀態：「播放中」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayingState</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體狀態：「暫停中」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PausedState</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體狀態：「停止中」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppedState</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(MusicPlayer* player)</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlayingState::play(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Already playing."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlayingState::pause(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pausing the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> PausedState()); <span class="comment">// 切換到暫停狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlayingState::stop(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> StoppedState()); <span class="comment">// 切換到停止狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PausedState::play(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resuming the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> PlayingState()); <span class="comment">// 切換回播放狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PausedState::pause(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Already paused."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PausedState::stop(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping the music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> StoppedState()); <span class="comment">// 切換到停止狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StoppedState::play(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting to play music."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    player-&gt;setState(<span class="keyword">new</span> PlayingState()); <span class="comment">// 切換到播放狀態</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StoppedState::pause(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't pause. The music is stopped."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StoppedState::stop(MusicPlayer* player) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Already stopped."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>音樂播放器本身只需要依賴狀態物件來決定它的行為，當狀態發生變化時，播放器自動切換狀態。這樣播放器不需要自己處理具體行為，所有的行為交給不同狀態來處理，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State* state; <span class="comment">// 當前狀態</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MusicPlayer(State* initState) : state(initState) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~MusicPlayer() &#123;</span><br><span class="line">        <span class="keyword">delete</span> state; <span class="comment">// 釋放當前狀態</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(State* newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> state; <span class="comment">// 切換狀態前釋放舊狀態</span></span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state-&gt;play(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state-&gt;pause(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state-&gt;stop(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們可以在客戶端直接使用這個播放器來進行播放、暫停、停止操作，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立播放器並初始化為停止狀態</span></span><br><span class="line">    <span class="function">MusicPlayer <span class="title">musicPlayer</span><span class="params">(<span class="keyword">new</span> StoppedState())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嘗試播放、暫停、停止操作</span></span><br><span class="line">    musicPlayer.play();    <span class="comment">// 開始播放</span></span><br><span class="line">    musicPlayer.pause();   <span class="comment">// 暫停播放</span></span><br><span class="line">    musicPlayer.play();    <span class="comment">// 恢復播放</span></span><br><span class="line">    musicPlayer.stop();    <span class="comment">// 停止播放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting to play music.</span><br><span class="line">Pausing the music.</span><br><span class="line">Resuming the music.</span><br><span class="line">Stopping the music.</span><br></pre></td></tr></table></figure></p><h2><span id="狀態模式的優缺點">狀態模式的優缺點</span></h2><p>狀態模式的優點是它可以讓物件的行為與其狀態緊密相關，當狀態變化時，行為也會隨之變化，這讓系統變得更加靈活且容易擴展。舉例來說，如果未來想新增「快進」狀態，我們只需定義新的 <code>FastForwardState</code> 類別，然後無需改動其他類別的邏輯。  </p><p>狀態模式的缺點在於會增加類別的數量。每個狀態都必須有一個對應的類別，這在狀態非常多的情況下，可能會讓程式變得繁瑣。另外動態切換狀態的過程中，可能會有一定的記憶體管理問題，需要小心處理。  </p><h2><span id="總結">總結</span></h2><p>狀態模式特別適合那些行為會隨著狀態改變而改變的系統。透過將狀態封裝成獨立的類別，系統可以變得更具擴展性，且更加容易維護。雖然可能會引入更多的類別和稍微複雜的結構，但它能有效地減少程式中繁瑣的判斷邏輯，讓程式碼更加清晰易懂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你在使用某些應用程式時，是否曾經發現它們的行為會隨著某些條件或狀態的改變而改變？例如音樂播放器，當它處於「播放」狀態時去按下「播放」按鈕是沒有反應的，但當處於「暫停」狀態時，按下相同按鈕就會繼續播放音樂。這樣的設計就是狀態模式的核心概念。  &lt;/p&gt;
&lt;h2&gt;&lt;span 
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 門面模式 Facade Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-facade-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-facade-pattern/</id>
    <published>2024-09-03T12:00:00.000Z</published>
    <updated>2024-09-06T14:20:06.559Z</updated>
    
    <content type="html"><![CDATA[<p>想像你剛買了一台全新的家電，同時是一台智慧家居控制中心。這台裝置可以控制家裡的燈光、空調、音響，甚至幫你泡咖啡！不過當你打開說明書，發現需要安裝十幾個不同的應用程式來單獨操控每個裝置時，這一切變得繁瑣起來。於是你會開始想如果有一個簡單的按鈕讓你輕鬆掌控所有裝置那該多好！這就是門面模式 Facade Pattern 的可以發揮的地方。門面模式讓我們可以簡化複雜系統的使用介面，將多個操作包裝成一個簡單的介面，讓使用者感到舒適和便利。  </p><h2><span id="什麼是門面模式">什麼是門面模式？</span></h2><p>門面模式是一種結構型設計模式，目的是為複雜系統提供一個簡單的介面，透過一個門面類別來隱藏系統的細節，讓使用者無需關心底層的運作方式。這個模式的核心思想就是隱藏系統的內部複雜度，對外提供一個簡單、統一的操作入口。  </p><p>具體來說，門面模式並不改變系統內部的運作邏輯，而是提供一個統一的「門面」來簡化與系統的互動。使用者只需透過這個門面進行操作，而無需了解系統內部的多個模組是如何協同工作的。  </p><h2><span id="門面模式在視訊轉換中的應用">門面模式在視訊轉換中的應用</span></h2><p>視訊轉換是一個非常複雜的過程，牽涉到解碼、轉碼、編碼、壓縮等多個步驟。假設你正在開發一個應用程式，目標是將一段視訊從一種格式轉換成另一種格式。如果讓使用者手動操作每個步驟，這對非技術背景的使用者來說無疑是個大挑戰。而門面模式非常適合這樣的應用場景。  </p><p>首先我們可以想像這個視訊轉換系統內部包含了多個模組，比如 <code>Decoder</code>、<code>Encoder</code>、<code>Compressor</code>、<code>AudioProcessor</code>、<code>SubtitleHandler</code> 和 <code>ResolutionAdjuster</code>，它們負責不同的視訊處理任務。為了讓使用者不需要關心這些細節，我們可以建立一個門面 <code>VideoConverterFacade</code>，讓這些模組協同工作。  </p><p>內部模組可能是這樣的，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; file)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Decoding "</span> &lt;&lt; file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; format)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Encoding to "</span> &lt;&lt; format &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Compressing video"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioProcessor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Processing audio..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubtitleHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addSubtitle</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; subtitleFile)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Adding subtitle: "</span> &lt;&lt; subtitleFile &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResolutionAdjuster</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustResolution</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Adjusting resolution to "</span> &lt;&lt; width &lt;&lt; <span class="string">"x"</span> &lt;&lt; height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們來實現門面類別，讓它來協調這些模組的工作，並提供一個簡單的操作方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoConverterFacade</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Decoder decoder;</span><br><span class="line">    Encoder encoder;</span><br><span class="line">    Compressor compressor;</span><br><span class="line">    AudioProcessor audioProcessor;</span><br><span class="line">    SubtitleHandler subtitleHandler;</span><br><span class="line">    ResolutionAdjuster resolutionAdjuster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convertVideo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; file, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; subtitleFile, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        decoder.decode(file);                      <span class="comment">// 解碼</span></span><br><span class="line">        audioProcessor.processAudio();             <span class="comment">// 處理音訊</span></span><br><span class="line">        subtitleHandler.addSubtitle(subtitleFile); <span class="comment">// 新增字幕</span></span><br><span class="line">        resolutionAdjuster.adjustResolution(width, height); <span class="comment">// 調整解析度</span></span><br><span class="line">        compressor.compress();                     <span class="comment">// 壓縮影片</span></span><br><span class="line">        encoder.encode(format);                    <span class="comment">// 編碼</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們可以在客戶端直接使用這個門面來進行視訊轉換，而無需了解內部的解碼、音訊、新增字幕、調整解析度、編碼和壓縮步驟，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VideoConverterFacade converter;</span><br><span class="line">    converter.convertVideo(<span class="string">"movie.mp4"</span>, <span class="string">"avi"</span>, <span class="string">"movie.srt"</span>, <span class="number">1920</span>, <span class="number">1080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Decoding movie.mp4</span><br><span class="line">Processing audio...</span><br><span class="line">Adding subtitle: movie.srt</span><br><span class="line">Adjusting resolution to 1920x1080</span><br><span class="line">Compressing video</span><br><span class="line">Encoding to avi</span><br></pre></td></tr></table></figure></p><p>在這個例子中，我們把多個步驟簡化成一個 <code>convertVideo</code> 方法，這讓使用者無需關心背後的具體操作，只需要指定原始檔案和目標格式即可完成任務。  </p><h2><span id="門面模式的優缺點">門面模式的優缺點</span></h2><p>門面模式的好處顯而易見，它簡化了使用者的操作體驗，讓他們不需要理解系統的複雜內部結構。這種方式提高了系統的可用性，尤其是當你有一個由多個子系統組成的複雜應用時，門面可以提供一個統一的入口，減少使用者的學習成本和操作壓力。  </p><p>同時門面模式也提升了系統的模組化，因為每個子系統依然保持相對獨立。如果需要修改內部實現或新增新功能，只需要改動子系統，門面本身不必大幅修改，這增強了系統的可擴展性。  </p><p>但門面模式也有缺點。當系統需求變得更加複雜時，門面的簡單操作可能無法滿足高階使用者的需求。他們可能希望能夠更深入地控制系統，這時門面反而可能會限制他們的靈活性。另外如果過度依賴門面來隱藏內部邏輯，可能會導致某些使用者忽視了系統真正的運作方式，導致未來難以進行細微的調整和除錯。  </p><h2><span id="總結">總結</span></h2><p>門面模式特別適合應用在那些需要隱藏系統複雜性的場景中。它透過提供一個簡單的介面，讓使用者能夠方便地與系統互動，無需深入了解內部細節。無論是在視訊轉換這樣的多步驟過程中，還是在其他複雜系統中，門面模式都能讓使用體驗更加友好且直觀。  </p><p>使用門面模式時也要權衡簡化操作與系統靈活性之間的平衡，確保系統在簡單易用的同時，也能滿足高階使用者的進階需求。畢竟簡單不代表犧牲功能，這就是門面模式所帶來的設計智慧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你剛買了一台全新的家電，同時是一台智慧家居控制中心。這台裝置可以控制家裡的燈光、空調、音響，甚至幫你泡咖啡！不過當你打開說明書，發現需要安裝十幾個不同的應用程式來單獨操控每個裝置時，這一切變得繁瑣起來。於是你會開始想如果有一個簡單的按鈕讓你輕鬆掌控所有裝置那該多好！這就
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 組合模式 Composite Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-composite-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-composite-pattern/</id>
    <published>2024-09-02T12:00:00.000Z</published>
    <updated>2024-09-05T14:00:07.479Z</updated>
    
    <content type="html"><![CDATA[<p>你有沒有遇過要同時處理單一物件與一群物件？就像在資料夾裡，你可以打開一個單獨的檔案，也可以打開一個資料夾，裡面可能包含了更多檔案或其他資料夾。這樣的層級結構看似複雜，但對使用者來說，我們希望能像操作單一檔案那樣簡單。這就是組合模式 Composite Pattern 的魔力所在，讓我們可以將單一物件與多個物件統一處理，創造出一個靈活且可擴展的層級架構。  </p><h2><span id="什麼是組合模式">什麼是組合模式？</span></h2><p>組合模式是一種結構型設計模式，它讓你能夠像處理單一物件一樣去操作物件的集合。在這個模式中，我們可以將物件組織成樹狀結構，透過將單一物件和組合物件視為同一個介面，實現對單一物件和複合物件的統一操作。  </p><p>簡單來說，組合模式解決了『如何讓樹狀結構中的物件與物件集合能被同樣對待』的問題。例如在一個UI系統中，按鈕、文字框等單一元素是葉子節點，而 Window、Panel 則是組合節點。我們希望能夠以相同的方式新增、移除和操作這些不同的元素，而不必區分它們是單一物件還是組合物件。  </p><p>組合模式通常包含以下角色：  </p><ol><li>元件（Component）：為所有具體元件和組合類定義共同的介面。  </li><li>葉節點（Leaf）：表示組合中的葉節點對象，葉節點沒有子節點。  </li><li>組合（Composite）：表示複雜元件，包含其他元件（可以是葉節點或其他複雜元件）。  </li><li>客戶端（Client）：通過元件介面與所有對象進行交互。  </li></ol><h2><span id="組合模式在圖形編輯器中的應用">組合模式在圖形編輯器中的應用</span></h2><p>讓我們來看一個圖形編輯器的例子。在圖形編輯器中，舉例：小畫家或其他類似工具，你可能會有單一的基本圖形（如圓形、矩形），也可能會有由多個基本圖形組成的複合圖形。組合模式讓我們可以使用相同的方式來操作這些基本圖形和複合圖形，無需關心它們的具體類型。  </p><p>我們先定義一個圖形的基礎介面 <code>Graphic</code>，讓所有圖形（單一圖形或組合圖形）都可以遵循相同的操作方式，例如：<code>draw</code> 跟 <code>move</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Graphic() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們來實現單一的圖形類別，比如 <code>Circle</code> 和 <code>Rectangle</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Graphic &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing Circle\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move the Circle to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Graphic &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing Rectangle\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move the Rectangle to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們實現一個組合圖形類別 <code>CompositeGraphic</code>，它可以包含多個圖形，不管是單一圖形還是其他複合圖形，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeGraphic</span> :</span> <span class="keyword">public</span> Graphic &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Graphic*&gt; graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Graphic* graphic)</span> </span>&#123;</span><br><span class="line">        graphics.push_back(graphic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; graphic : graphics) &#123;</span><br><span class="line">            graphic-&gt;draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move graphic to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">"):\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; graphic : graphics) &#123;</span><br><span class="line">            graphic-&gt;move(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在這裡我們將建立單一的圖形物件和組合的圖形物件，並使用相同的方式來操作它們，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立單一圖形</span></span><br><span class="line">    Circle circle;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立組合圖形</span></span><br><span class="line">    CompositeGraphic composite;</span><br><span class="line">    composite.add(&amp;circle);</span><br><span class="line">    composite.add(&amp;rectangle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次建立一個複合圖形並巢狀</span></span><br><span class="line">    CompositeGraphic complexComposite;</span><br><span class="line">    complexComposite.add(&amp;composite);</span><br><span class="line">    complexComposite.add(&amp;circle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 繪製所有圖形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Drawing composite graphic:\n"</span>;</span><br><span class="line">    complexComposite.draw();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移動所有圖形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move composite graphic:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    complexComposite.move(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Drawing composite graphic:</span><br><span class="line">Drawing Circle</span><br><span class="line">Drawing Rectangle</span><br><span class="line">Drawing Circle</span><br><span class="line">Move composite graphic:</span><br><span class="line">Move graphic to (10, 20):</span><br><span class="line">Move graphic to (10, 20):</span><br><span class="line">Move the Circle to (10, 20)</span><br><span class="line">Move the Rectangle to (10, 20)</span><br><span class="line">Move the Circle to (10, 20)</span><br></pre></td></tr></table></figure></p><p>在這個例子中，<code>CompositeGraphic</code> 允許我們將單一圖形和其他組合圖形一起處理，無需區分它們是單一圖形還是由多個圖形組成的組合。這樣一來整個圖形編輯器的結構變得更加靈活，讓我們能夠輕鬆管理複雜的圖形組合。  </p><h2><span id="組合模式的優缺點">組合模式的優缺點</span></h2><p>組合模式的最大優勢在於它讓系統結構更加簡單和靈活。無論我們處理的是單一物件還是複合物件，都可以使用同樣的介面，這降低了處理不同類型物件時的複雜性。另外組合模式讓我們可以輕鬆地擴展系統，只需新增更多類型的物件或組合物件，而不必修改現有的程式碼。  </p><p>組合模式也帶來了額外的設計複雜度。當我們的物件結構變得非常複雜時，理解和管理這些層級可能會變得困難。此外對於只需要處理單一物件的情況來說，組合模式的額外靈活性可能是多餘的，反而會增加系統的負擔。  </p><h2><span id="總結">總結</span></h2><p>組合模式讓我們能夠用統一的方式處理單一物件和複合物件。它廣泛應用於各種層級結構中，例如圖形編輯器、檔案系統、UI 元素等。雖然這個模式能夠簡化對複雜物件結構的處理，但它也可能帶來一些設計上的挑戰，因此在使用時需要謹慎考量其適用性。  </p><p>當你下次面對需要同時處理單一和多個物件的情況時，組合模式可能正是解決問題的鑰匙。無論是單一物件還是複合物件，最終它們都應該能夠被簡單而一致地操作，這就是組合模式的魅力所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你有沒有遇過要同時處理單一物件與一群物件？就像在資料夾裡，你可以打開一個單獨的檔案，也可以打開一個資料夾，裡面可能包含了更多檔案或其他資料夾。這樣的層級結構看似複雜，但對使用者來說，我們希望能像操作單一檔案那樣簡單。這就是組合模式 Composite Pattern 的魔力
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 轉接器模式 Adapter Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-adapter-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-adapter-pattern/</id>
    <published>2024-09-01T12:00:00.000Z</published>
    <updated>2024-09-04T13:30:07.516Z</updated>
    
    <content type="html"><![CDATA[<p>當你旅行時，面對世界各地形形色色的插座，每個國家的插座形狀和電壓都可能不一樣，而你只帶了一台手機充電器。如果沒有一個合適的插頭轉接器，你的電子裝置將無法使用，例如台灣手機充電器帶去歐洲不能直接使用，接上了轉接頭就可以使用了。這個轉接器的角色就像是軟體開發中的轉接器模式 Adapter Pattern。在軟體開發中，我們經常需要整合不同的系統或使用第三方函式庫。但有時這些系統或函式庫的介面與我們的程式碼不相容。轉接器模式它的功能在於讓兩個原本不相容的介面協同工作，讓你可以在不更改既有程式碼的情況下，輕鬆地整合不同的系統或類別。  </p><h2><span id="什麼是轉接器模式">什麼是轉接器模式？</span></h2><p>轉接器模式是一種結構型設計模式，它將原本介面不相容而不能一起工作的類能夠協同工作。簡單來說，轉接器就像是一個轉換器，將一個類的介面轉換成客戶端所期望的另一種介面。  </p><p>這種模式讓原本不相容的類可以一起工作，而無需修改它們的原始碼。它在我們需要使用一個現有的類，但是其介面與我們的需求不匹配時特別有用。  </p><p>轉接器模式通常用於解決因現有程式碼無法修改或類別不相容而導致的整合問題。加入轉接器後，我們可以在不更改既有類別的情況下，實現介面的一致性，達到程式碼的複用性和擴展性。  </p><p>轉接器模式通常包含以下角色：  </p><ol><li>目標介面（Target）：客戶端所期望的介面。  </li><li>轉接者（Adaptee）：需要被轉接的類，它有著不相容的介面。  </li><li>轉接器（Adapter）：將轉接者的介面轉換為目標介面的類別。  </li></ol><h2><span id="轉接器模式在json到xml轉換中的應用">轉接器模式在JSON到XML轉換中的應用</span></h2><p>讓我們用一個例子來理解轉接器模式：JSON到XML的資料格式轉換。  </p><p>假設你正在開發一個系統，這個系統需要處理XML格式的資料。但是你發現有一個非常好用的第三方函式庫，可以提供你所需的所有資料，唯一的問題是這個函式庫輸出的是JSON格式。這時就可以使用轉接器模式幫助我們解決這個問題。  </p><p>讓我們用程式碼來模擬這個場景：  </p><p>首先我們定義目標介面（XML資料提供者），<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLData</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getXMLData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們有一個現有的類（JSON資料提供者），它的介面與目標介面不相容，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONData</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getJSONData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"name\": \"John\", \"age\": 30&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們建立一個轉接器類，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONToXMLAdapter</span> :</span> <span class="keyword">public</span> XMLData &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    JSONData* jsonData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JSONToXMLAdapter(JSONData* data) : jsonData(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getXMLData</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> jsonData = <span class="keyword">this</span>-&gt;jsonData-&gt;getJSONData();</span><br><span class="line">        <span class="comment">// 實際的JSON到XML的轉換邏輯</span></span><br><span class="line">        <span class="comment">// 為了簡化，我們只做一個模擬的轉換</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> xmlData = <span class="string">"&lt;person&gt;&lt;name&gt;John&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;&lt;/person&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> xmlData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後客戶端（使用者）可以這樣使用，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONData* jsonData = <span class="keyword">new</span> JSONData();</span><br><span class="line">    XMLData* xmlData = <span class="keyword">new</span> JSONToXMLAdapter(jsonData);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"XML Data: "</span> &lt;&lt; xmlData-&gt;getXMLData() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> xmlData;</span><br><span class="line">    <span class="keyword">delete</span> jsonData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這個例子中，<code>JSONToXMLAdapter</code> 類扮演了轉接器的角色。它實現了 <code>XMLData</code> 介面，同時內部持有一個 <code>JSONData</code> 物件。當呼叫 <code>getXMLData()</code> 方法時，轉接器會先取得JSON資料，然後將其轉換為XML格式，從而實現了從JSON到XML的轉換。  </p><h2><span id="轉接器模式的優缺點">轉接器模式的優缺點</span></h2><p>轉接器模式的一個顯著優點是，透過使用轉接器我們可以讓原本不相容的系統或類別協同工作，而無需修改它們的原始程式碼。這在處理第三方庫或舊系統時特別有用，因為我們通常無法直接修改這些程式碼。另外轉接器模式還遵循了開放封閉原則，允許我們引入新的轉接器而不會破壞現有的程式碼。  </p><p>轉接器模式也有缺點。它增加了系統的複雜性，因為引入了新的類和介面。在某些情況下，過度使用轉接器可能會導致程式碼難以理解和維護。由於轉接器模式涉及到不同類別介面之間的轉換，這可能會導致一些性能開銷，特別是在大型應用中，頻繁的介面轉換可能會對系統的效能產生影響，因為它在原介面和目標介面之間增加了一個間接層。  </p><h2><span id="總結">總結</span></h2><p>轉接器模式是一種強大的工具，讓我們可以輕鬆地解決系統整合和類別不相容的問題。透過這種模式我們能夠在不改變既有程式碼的前提下，加入新功能或整合外部系統，從而提高系統的靈活性和可擴展性。然而在使用轉接器模式時，也需要考慮到其可能帶來的效能消耗和程式碼複雜性問題。但在許多情況下，轉接器模式帶來的靈活性和複用性遠遠超過了這些小缺點。作為一個優秀的軟體工程師，了解並正確使用轉接器模式可以幫助你更好地處理現實世界中的各種介面不相容問題。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你旅行時，面對世界各地形形色色的插座，每個國家的插座形狀和電壓都可能不一樣，而你只帶了一台手機充電器。如果沒有一個合適的插頭轉接器，你的電子裝置將無法使用，例如台灣手機充電器帶去歐洲不能直接使用，接上了轉接頭就可以使用了。這個轉接器的角色就像是軟體開發中的轉接器模式 Ad
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 建造者模式 Builder Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-builder-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-builder-pattern/</id>
    <published>2024-08-31T12:00:00.000Z</published>
    <updated>2024-09-03T13:20:06.981Z</updated>
    
    <content type="html"><![CDATA[<p>當你進入餐廳點餐時，菜單上琳瑯滿目的選擇可能讓你感到無從下手。你可以選擇一個套餐，但如果你有特別的需求，例如多點一份沙拉，少放一點醬料，這時候就需要進行個性化的訂單。而這樣的流程，正是建造者模式 Builder Pattern 的精髓所在。它不僅在生活中隨處可見，在軟體設計中更是強大而實用的一種模式。  </p><h2><span id="什麼是建造者模式">什麼是建造者模式？</span></h2><p>建造者模式是一種建立型設計模式，它將物件的建立過程分解為多個步驟，並且可以根據需求有選擇地組合這些步驟，最終產生我們所需的物件。這樣的設計模式特別適合用於那些需要一步步構建，且每一步可能有不同選擇的複雜物件。  </p><p>建造者模式通常包含以下角色：  </p><ol><li>Product（產品）：最終被構建的複雜物件。  </li><li>Builder（建造者）：定義構建物件的抽象介面。  </li><li>ConcreteBuilder（具體建造者）：實現 Builder 介面，提供具體的構建步驟。  </li><li>Director（指揮者）：負責使用建造者來構建產品，控制建造的過程。  </li></ol><h2><span id="建造者模式在訂製汽車中的應用">建造者模式在訂製汽車中的應用</span></h2><p>讓我們以訂製汽車為例來說明建造者模式的應用。想像你正在購買一輛新車，經銷商會給你提供一系列選項，從引擎、輪胎到內裝，你可以自由選擇搭配，打造一輛專屬於你的車輛。這正是建造者模式最典型的應用場景。  </p><p>我們需要定義最終要建造的產品 <code>Car</code> 類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 產品類 Product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> engine;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> wheels;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> interior;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; engineType)</span> </span>&#123;</span><br><span class="line">        engine = engineType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWheels</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; wheelType)</span> </span>&#123;</span><br><span class="line">        wheels = wheelType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInterior</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; interiorType)</span> </span>&#123;</span><br><span class="line">        interior = interiorType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSpecifications</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Engine: "</span> &lt;&lt; engine &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">                  &lt;&lt; <span class="string">"Wheels: "</span> &lt;&lt; wheels &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">                  &lt;&lt; <span class="string">"Interior: "</span> &lt;&lt; interior &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再定義一個 <code>Builder</code> 介面，它包含了構建汽車各部分的方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者介面 Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildWheels</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildInterior</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">getCar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~CarBuilder() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們建立具體的建造者類別，例如一個豪華汽車的建造者，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體建造者 ConcreteBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuxuryCarBuilder</span> :</span> <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car* car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LuxuryCarBuilder() &#123;</span><br><span class="line">        car = <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildEngine</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        car-&gt;setEngine(<span class="string">"V8 Turbo Engine"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildWheels</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        car-&gt;setWheels(<span class="string">"Alloy Wheels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildInterior</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        car-&gt;setInterior(<span class="string">"Leather Interior"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car* <span class="title">getCar</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們建立一個指揮者來控制建造的過程，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指揮者 Director</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarDirector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CarBuilder* builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CarDirector(CarBuilder* builder) : builder(builder) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car* <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder-&gt;buildEngine();</span><br><span class="line">        builder-&gt;buildWheels();</span><br><span class="line">        builder-&gt;buildInterior();</span><br><span class="line">        <span class="keyword">return</span> builder-&gt;getCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>當你需要訂製一輛豪華汽車時，只需透過建造者模式來構建它，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CarBuilder* builder = <span class="keyword">new</span> LuxuryCarBuilder();</span><br><span class="line">    <span class="function">CarDirector <span class="title">director</span><span class="params">(builder)</span></span>;</span><br><span class="line">    Car* car = director.construct();</span><br><span class="line"></span><br><span class="line">    car-&gt;showSpecifications();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> car;</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這樣的設計讓我們可以輕鬆地改變汽車的設定，或者在需要時引入新的建造者，而不必修改現有的邏輯。建造者模式提供了靈活的物件構建過程，使得我們可以在不同需求下產生不同的產品。  </p><h2><span id="建造者模式的優缺點">建造者模式的優缺點</span></h2><p>建造者模式的優點在於它的靈活性和可擴展性。由於構建過程是分步驟進行的，我們可以輕鬆地在不同的情境下進行客製化，無論是增加新功能還是修改現有步驟，都不會影響整個系統的設計。這樣的設計模式特別適合那些物件結構複雜且需要逐步構建的場景。  </p><p>建造者模式也有缺點。由於每一個具體建造者都必須實現所有的建造步驟，這會導致大量的程式碼重複，特別是在類似的建造者之間。並且當物件的構建步驟過多時，可能會使得建造者變得臃腫，降低了程式碼的可讀性與維護性。另外指揮者雖然讓建造過程更具組織性，但也可能產生額外的複雜度。  </p><h2><span id="總結">總結</span></h2><p>建造者模式特別適合於建立複雜物件或者需要靈活設定的物件。它就像是一個精密的工廠流水線，可以根據不同的需求生產出不同的產品，而且每個產品都保持品質與一致性。在現代軟體開發中，無論是複雜的汽車製造、蓋房屋，還是表單產生器，建造者模式都能幫助我們應對，當你下次面對需要建立複雜物件，或者需要根據不同情況建立不同類型物件的場景時，不妨考慮使用建造者模式。它可能正是你解決問題的關鍵。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;當你進入餐廳點餐時，菜單上琳瑯滿目的選擇可能讓你感到無從下手。你可以選擇一個套餐，但如果你有特別的需求，例如多點一份沙拉，少放一點醬料，這時候就需要進行個性化的訂單。而這樣的流程，正是建造者模式 Builder Pattern 的精髓所在。它不僅在生活中隨處可見，在軟體設計
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 命令模式 Command Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-command-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-command-pattern/</id>
    <published>2024-08-30T12:00:00.000Z</published>
    <updated>2024-09-01T14:00:07.554Z</updated>
    
    <content type="html"><![CDATA[<p>想像你正坐在一間高級餐廳裡。你不會直接走進廚房告訴廚師你想吃什麼，而是向服務生點餐。服務生記下你的要求，然後將其傳達給廚房。這個看似簡單的過程，其實蘊含了一個軟體設計概念，那就是命令模式 Command Pattern。今天我們就來聊聊這個讓程式碼更具彈性的設計模式。  </p><h2><span id="什麼是命令模式">什麼是命令模式？</span></h2><p>命令模式是一種行為設計模式，它將一個請求封裝成一個物件，從而使你可以用不同的請求對客戶進行參數化。簡單來說，它就像是餐廳裡的點餐單，將”做什麼”與”誰來做”分離開來。  </p><p>在軟體設計中，命令模式允許我們將一個操作（比如打開電燈）封裝成一個物件。這個物件包含了執行這個操作所需的所有資訊。這樣我們就可以在不知道操作具體內容或操作接收者的情況下，執行這個操作或者將其傳遞給其他程式碼。  </p><p>命令模式通常包含以下幾個角色：  </p><ol><li>Command（命令）：定義了命令的介面，所有具體命令都必須實現這個介面。  </li><li>ConcreteCommand（具體命令）：實現 Command 介面，將一個接收者物件綁定到一個動作。這樣當命令被呼叫時，對應的接收者就會執行相應的動作。</li><li>Invoker（呼叫者）：負責呼叫命令。  </li><li>Receiver（接收者）：實際執行命令的邏輯或動作。  </li></ol><h2><span id="命令模式在智慧家庭中的應用">命令模式在智慧家庭中的應用</span></h2><p>讓我們以智慧家庭的應用來解釋命令模式。假設你有一個智慧家庭系統，透過這個系統你可以控制家中的各種裝置，比如燈光、空調、音響等。當你想要打開燈光時，你不會去直接呼叫燈光的操作介面，而是透過智慧家庭系統發出一個命令來控制燈光的開關。這就是命令模式的典型應用。  </p><p>首先我們定義一個 <code>Command</code> 介面，它包含一個 <code>execute</code> 方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令介面 Command</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Command() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們為每一個裝置（如燈光）建立具體的命令類別，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者 Receiver</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Light is ON"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Light is OFF"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體命令 ConcreteCommand</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> :</span> <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light* light;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LightOnCommand(Light* light) : light(light) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        light-&gt;on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> :</span> <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light* light;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LightOffCommand(Light* light) : light(light) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        light-&gt;off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們建立一個呼叫者類別，它含有一個命令物件，可以執行這個命令，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 呼叫者 Invoker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command* command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command* command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pressButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command-&gt;execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在當你想要開燈時，只需要透過命令模式來控制它，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Light* light = <span class="keyword">new</span> Light();</span><br><span class="line">    Command* lightOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">    Command* lightOff = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line"></span><br><span class="line">    RemoteControl* remote = <span class="keyword">new</span> RemoteControl();</span><br><span class="line"></span><br><span class="line">    remote-&gt;setCommand(lightOn);</span><br><span class="line">    remote-&gt;pressButton();  <span class="comment">// 打開燈光</span></span><br><span class="line"></span><br><span class="line">    remote-&gt;setCommand(lightOff);</span><br><span class="line">    remote-&gt;pressButton();  <span class="comment">// 關閉燈光</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> light;</span><br><span class="line">    <span class="keyword">delete</span> lightOn;</span><br><span class="line">    <span class="keyword">delete</span> lightOff;</span><br><span class="line">    <span class="keyword">delete</span> remote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這樣的設計讓我們可以輕鬆擴展新的裝置和命令，無需修改現有的程式碼。呼叫者完全不需要知道具體的裝置，只需呼叫對應的命令即可。  </p><h2><span id="命令模式的優缺點">命令模式的優缺點</span></h2><p>命令模式的優點在於它將請求的發送者和接收者解耦，使得系統更加靈活。就像我們的智能家居例子，遙控器（發送者）不需要知道是哪個裝置（接收者）在執行命令。這種解耦使得我們可以輕鬆地新增新的命令，而無需修改現有的程式碼。此外，命令模式還支援撤銷操作、讓操作可以被記錄、重做或者排程等進階功能，例如，你可以實現一個「撤銷」功能，只需將執行過的命令記錄下來，當需要撤銷時，呼叫相反的命令即可。  </p><p>命令模式也有其缺點。由於每個具體命令都被封裝成一個單獨的類，它可能導致系統中的類數量暴增。這可能使得系統變得更加複雜，特別是當只有少量簡單命令時。其次，如果命令的執行涉及到大量的業務邏輯，那麼命令類可能變得臃腫，違反了單一職責原則。  </p><h2><span id="總結">總結</span></h2><p>命令模式是一個強大且靈活的設計模式，能夠讓我們的程式設計更具組織性和可擴展性。雖然它可能會引入一些額外的複雜度，但在許多情境下，它所帶來的好處遠遠超過其缺點。在智慧家庭、遊戲開發以及企業級應用中，命令模式的應用無處不在。好的設計模式就像好的工具一樣，關鍵是要在適當的場景中恰當地使用它們。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你正坐在一間高級餐廳裡。你不會直接走進廚房告訴廚師你想吃什麼，而是向服務生點餐。服務生記下你的要求，然後將其傳達給廚房。這個看似簡單的過程，其實蘊含了一個軟體設計概念，那就是命令模式 Command Pattern。今天我們就來聊聊這個讓程式碼更具彈性的設計模式。  &lt;
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 代理模式 Proxy Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-proxy-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-proxy-pattern/</id>
    <published>2024-08-29T12:00:00.000Z</published>
    <updated>2024-09-01T14:10:07.055Z</updated>
    
    <content type="html"><![CDATA[<p>在日常生活中，我們常常遇到這樣的情況：你想要完成某件事情，但由於種種原因，你無法直接接觸到那個目標，於是你請來了一個「代理」來幫你處理一切。例如你需要買一台很難找的限量版遊戲機，但由於時間或距離問題，你沒辦法親自去購買，所以你委託了一個代購服務。而這個代購就是你的「代理」。在軟體設計中，代理模式 Proxy Pattern 就是利用類似的概念，讓一個物件（代理）代表另一個物件來控制對它的存取。聽起來有點抽象？別擔心，我們馬上進入正題。  </p><h2><span id="什麼是代理模式">什麼是代理模式？</span></h2><p>代理模式是一種結構型設計模式，代理模式的核心思想是：為某個物件提供一個替代者，以控制對這個物件的存取。這樣做的好處是你可以在不改變原物件的情況下，新增一些額外的功能，或是對存取進行控制。代理模式可以被看作是一個中間層，這個中間層負責把客戶端的請求轉發給真實物件，並在過程中執行一些額外的邏輯。  </p><p>假如你是一位繁忙的企業高階經理，每天都有無數的會議和決策要處理。這時候一個得力的助理就顯得重要。助理可以幫你過濾不重要的事物，安排你的行程，甚至代表你參加一些會議。這個助理就是現實生活中的「代理」。  </p><p>簡單來說，代理模式中有三個角色：  </p><ol><li>Subject：定義了客戶端可以呼叫的方法。  </li><li>RealSubject：實際執行請求的真實物件。  </li><li>Proxy：代理物件，負責控制對 RealSubject 的存取。  </li></ol><h2><span id="代理模式在網頁載入中的應用">代理模式在網頁載入中的應用</span></h2><p>讓我們以網頁載入的例子來解釋代理模式的實際應用。假設我們有一個網站，其中包含許多高解析度的圖片，這些圖片可能會因為其大容量而導致網頁載入緩慢。為了優化使用者體驗，我們可以使用代理模式，先顯示一個縮圖，等使用者真的需要查看大圖時，再去載入原圖。  </p><p>首先我們定義一個 <code>Image</code> 介面，裡面有一個方法 <code>display</code>，用來顯示圖片，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象介面 Subject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Image() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們實現這個介面來載入並顯示實際的圖片，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 實際主題 RealSubject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> :</span> <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> filename;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Loading "</span> &lt;&lt; filename &lt;&lt; <span class="string">" from disk\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealImage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename) : filename(filename) &#123;</span><br><span class="line">        loadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Displaying "</span> &lt;&lt; filename &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後我們實現一個 <code>ProxyImage</code> 來控制對 <code>RealImage</code> 的存取，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理物件 Proxy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> :</span> <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> filename;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RealImage&gt; realImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProxyImage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename) : filename(filename), realImage(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!realImage) &#123;</span><br><span class="line">            <span class="comment">// lazy initialization</span></span><br><span class="line">            realImage = <span class="built_in">std</span>::make_unique&lt;RealImage&gt;(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage-&gt;display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在客戶端只需透過代理物件來存取圖片，而不必直接接觸到大圖片本身：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客戶端程式碼</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Image&gt; image1 = <span class="built_in">std</span>::make_unique&lt;ProxyImage&gt;(<span class="string">"photo1.jpg"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Image&gt; image2 = <span class="built_in">std</span>::make_unique&lt;ProxyImage&gt;(<span class="string">"photo2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 圖像將從磁碟載入</span></span><br><span class="line">    image1-&gt;display();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 圖像不會再次從磁碟載入，直接顯示</span></span><br><span class="line">    image1-&gt;display();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 圖像將從磁碟載入</span></span><br><span class="line">    image2-&gt;display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這個例子中，第一次呼叫 <code>display()</code> 方法時，代理會建立並載入真實圖片。當第二次呼叫時，圖片已經被載入過，因此不會再次載入，直接顯示圖片內容。這樣的處理方式避免了不必要的效能消耗，還提升了效率。  </p><h2><span id="代理模式的優缺點">代理模式的優缺點</span></h2><p>代理模式帶來了許多好處，最顯而易見的是它能讓我們有效地控制對目標物件的存取。這表示我們可以根據需求延遲載入資源、設定存取權限，甚至在某些情況下，讓一個代理物件負責管理多個請求，進而優化系統的效能。另外代理模式提供了一種優雅的方式，在不改變原有類別的基礎上新增額外功能，這讓我們的程式設計更加靈活，能更好地應對未來的變化。  </p><p>代理模式也不是沒有缺點，導入代理會在客戶端和真實物件之間增加一個間接層，這可能會導致系統變得更加複雜。如果代理類別中包含了太多額外的邏輯，可能會影響效能。  </p><h2><span id="總結">總結</span></h2><p>代理模式是一個實用且靈活的設計模式，適合用於需要控制存取或增加功能的場景中。它的應用非常廣泛，例如虛擬代理、保護代理、智慧代理等，每一種代理模式都有其獨特的價值。但我們也要注意避免因為濫用代理模式而導致系統過度複雜。  </p><p>就像現實生活中的經紀人或助理一樣，代理為我們處理了許多複雜的細節，讓我們能夠專注於更重要的事務。下次當你面臨需要控制對對象的存取，或者需要在存取前後添加額外邏輯的情況時，不妨考慮使用代理模式。它可能正是你所需要的解決方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常生活中，我們常常遇到這樣的情況：你想要完成某件事情，但由於種種原因，你無法直接接觸到那個目標，於是你請來了一個「代理」來幫你處理一切。例如你需要買一台很難找的限量版遊戲機，但由於時間或距離問題，你沒辦法親自去購買，所以你委託了一個代購服務。而這個代購就是你的「代理」。
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 簡單工廠模式 Simple Factory Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-simple-factory-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-simple-factory-pattern/</id>
    <published>2024-08-28T12:00:00.000Z</published>
    <updated>2024-09-08T02:40:06.939Z</updated>
    
    <content type="html"><![CDATA[<p>在設計模式中，簡單工廠方法模式 Simple Factory Pattern 是一個常見的設計模式，特別適合用來解決物件建立的問題。今天我們就來用一個大家耳熟能詳的特斯拉汽車工廠例子來解釋這個模式。  </p><p>而工廠模式的核心思想是，將物件的建立過程封裝起來，客戶端只需要知道自己需要什麼，而不需要關心如何製作。  </p><h2><span id="什麼是簡單工廠模式">什麼是簡單工廠模式？</span></h2><p>簡單工廠模式是非正式的設計模式，它比較是一個寫程式技巧，一般在講工廠模式通常指的是簡單工廠模式，在設計模式中，簡單工廠模式通常指的是建立者（工廠）沒有子類，而產品可以有子類。  </p><p>具體來說，簡單工廠模式中工廠本身是一個靜態的方法或單一的類別，根據給定的參數來決定建立哪一種類型的物件。這個工廠類別通常不會有子類，因為它的目的就是統一處理產品的建立邏輯。然而工廠所產生的產品類別可以有不同的子類，以實現不同的具體產品。  </p><p>例如有一個簡單工廠負責生產汽車，這個工廠可以根據需求產生不同類型的汽車（如電動車、油車）。在這個場景下，工廠本身不會有子類，但生產出來的產品（汽車）可能有多個子類，代表不同類型的汽車。  </p><h2><span id="簡單工廠模式在特斯拉汽車工廠的應用">簡單工廠模式在特斯拉汽車工廠的應用</span></h2><p>讓我們用特斯拉的汽車工廠來說明這個概念。這座汽車工廠能夠生產四種不同的車型：Model 3、Model Y、Model S 和 Model X。在這個例子裡我們將這四種車型視為不同的「產品類別」，而工廠則是負責建立這些車型物件的地方。  </p><p>假設我們沒有使用工廠模式，每當需要建立一輛新的車，我們就必須自己手動選擇車型的類別並建立物件，像這樣寫，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; myCar = <span class="built_in">std</span>::make_unique&lt;Model3&gt;();</span><br><span class="line"><span class="comment">// 或傳統指標</span></span><br><span class="line">Car* myCar = <span class="keyword">new</span> Model3();</span><br></pre></td></tr></table></figure></p><p>這種方式看起來簡單直接，但當我們的應用程式需要根據不同的條件來建立不同的車型時，程式碼就會變得很複雜，而且如果未來需要增加新的車型，我們就需要到每一處使用這段程式碼的地方進行修改，這非常容易出錯。  </p><p>我們首先定義一個簡單的工廠類別 <code>CarFactory</code>，這個類別有一個靜態方法 <code>createCar</code>，根據傳入的車型名稱來建立對應的車型物件，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; createCar(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; carType) &#123;</span><br><span class="line">        <span class="keyword">if</span> (carType == <span class="string">"Model 3"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Model3&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (carType == <span class="string">"Model S"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;ModelS&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (carType == <span class="string">"Model X"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;ModelX&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (carType == <span class="string">"Model Y"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;ModelY&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用工廠模式後，我們只需要簡單地告訴工廠我們需要什麼車型即可，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; myCar = CarFactory::createCar(<span class="string">"Model 3"</span>);</span><br><span class="line"><span class="comment">// 或傳統指標</span></span><br><span class="line">Car* myCar = CarFactory::createCar(<span class="string">"Model 3"</span>);</span><br></pre></td></tr></table></figure></p><p>這樣一來，如果未來特斯拉推出了新的車型，例如 <code>Model Z</code>，我們只需修改 <code>CarFactory</code> 類別，新增對 <code>Model Z</code> 的支援，而不需要去改動使用了 <code>CarFactory</code> 的所有地方。  </p><h2><span id="簡單工廠方法模式的優缺點">簡單工廠方法模式的優缺點</span></h2><p>簡單工廠模式的最大優點就是它的「簡單」。你只需要告訴工廠你想要什麼，它就能幫你生產出來。這讓程式碼變得更直觀，容易理解。所有的建立邏輯都集中在一個地方（工廠類別），如果我們要修改或新增新產品，只需要動這個工廠類別內的邏輯，其他地方的程式碼不受影響，也不需要去修改客戶端的程式碼，這樣即使需求變動，也可以輕鬆應對。  </p><p>簡單工廠模式的缺點就是所有的建立邏輯都集中在工廠類別中，如果這個工廠要處理很多不同的產品類別，它會變得非常龐大和複雜，違反了「單一職責原則」。雖然新增新產品相對容易，但如果工廠需要產生的產品越來越多，工廠類別的邏輯也會越來越複雜，導致它變得難以維護和修改。簡單工廠適合處理簡單的物件建立需求，但如果每個產品的建立過程都很複雜，工廠就會變得難以維持。  </p><h2><span id="簡單工廠模式跟工廠方法模式的差別">簡單工廠模式跟工廠方法模式的差別</span></h2><p>簡單工廠模式和工廠方法模式是兩種不同的設計模式，各自有不同的用途和適用場景，但它們確實有一定的關聯性。  </p><p>簡單工廠模式（Simple Factory Pattern）並不被視為一個正式的設計模式，更像是一個寫程式技巧。它集中了一個工廠類來生產產品，通常使用一個靜態方法根據參數決定要建立的物件。這樣做的好處是簡單易用，但缺點在於違反了「開放封閉原則」，也就是如果需要擴展產品類型，就必須修改工廠的程式碼。  </p><p>工廠方法模式（Factory Method Pattern）是一個正式的設計模式，屬於建立型設計模式之一。它的核心思想是將建立物件的過程延遲到子類別，透過定義一個工廠接口，讓子類別決定具體要實例化的產品類型。這樣，工廠方法模式解決了簡單工廠的缺點，符合「開放封閉原則」，因為新增產品類型時不需要修改已有的程式碼，只需擴展子類別即可。  </p><p>可以說簡單工廠模式是工廠方法模式的簡化，而工廠方法模式是簡單工廠模式的改良版，更靈活但也更複雜。工廠方法模式讓系統更具擴展性，特別是在需要經常擴展產品種類的場景中更有優勢。  </p><p>在實際開發中，選擇哪種模式取決於項目的複雜度和未來的擴展需求。如果產品類型較少且變化不大，簡單工廠模式是一個快速且簡單的選擇；如果產品類型多且經常變化，工廠方法模式則能提供更好的擴展性和可維護性。  </p><h2><span id="總結">總結</span></h2><p>工廠模式的核心思想是：<strong>把物件的建立過程封裝起來，使得客戶端（使用者）不需要關心具體物件是如何建立的，只需透過工廠來取得所需的物件。</strong>這樣不僅減少了客戶端的複雜度，也增加了系統的靈活性，因為我們可以輕鬆地改變建立物件的方式，而不影響使用者的程式碼。  </p><p>簡單工廠模式就像是一個自動化的汽車生產工廠，讓我們能夠方便地建立不同的物件。透過這個例子，我們能夠看到這種設計模式如何讓我們的程式碼變得更簡潔、更易於維護。就像特斯拉工廠能夠快速應對市場需求，生產出各式各樣的車型，我們的程式碼也能夠靈活地產生各種物件來應對不同的需求。  </p><p><strong>其它相關文章推薦</strong><br>如果你想學習設計模式相關技術，可以參考看看下面的文章，<br><a href="/cpp-factory-method-pattern/" title="工廠方法模式 Factory Method Pattern">工廠方法模式 Factory Method Pattern</a><br><a href="/cpp-abstract-factory-pattern/" title="抽象工廠模式 Abstract Factory Pattern">抽象工廠模式 Abstract Factory Pattern</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在設計模式中，簡單工廠方法模式 Simple Factory Pattern 是一個常見的設計模式，特別適合用來解決物件建立的問題。今天我們就來用一個大家耳熟能詳的特斯拉汽車工廠例子來解釋這個模式。  &lt;/p&gt;
&lt;p&gt;而工廠模式的核心思想是，將物件的建立過程封裝起來，客戶端
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 抽象工廠模式 Abstract Factory Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-abstract-factory-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-abstract-factory-pattern/</id>
    <published>2024-08-27T12:00:00.000Z</published>
    <updated>2024-09-08T02:40:06.939Z</updated>
    
    <content type="html"><![CDATA[<p>在學習設計模式時，你可能會遇到一個問題：「為什麼有這麼多工廠模式？他們到底在解決什麼問題？」工廠方法模式（Factory Method Pattern）提供了一個方法來建立物件，這個方法可以在子類中覆蓋，以便建立不同類型的物件。而抽象工廠模式（Abstract Factory Pattern）則進一步擴展，允許你建立一系列相關的物件，這對於組織和管理大型系統非常有幫助。今天我們將透過一個GUI（圖形使用者界面）的例子來解釋這個概念。  </p><h2><span id="什麼是抽象工廠模式">什麼是抽象工廠模式？</span></h2><p>抽象工廠模式的核心思想是提供一個接口，讓客戶端程式能夠產生一系列相關的或相互依賴的物件，而不必指定具體的類型。這種模式特別適合用於需要產生不同風格或主題的GUI元件的場景。假設我們正在開發一個跨平台的應用程式，該應用可以執行在Windows、macOS、Linux等多個平台上，並且每個平台都有自己獨特的GUI風格。在這種情況下使用抽象工廠模式可以讓我們輕鬆地為不同平台產生相應風格的GUI元件。  </p><p>在解釋具體範例之前，讓我們先來看一下抽象工廠模式中的幾個核心角色：<br>抽象工廠（Abstract Factory）：定義建立一系列相關物件的方法接口。這些方法通常與產品家族有關，例如在GUI應用中，這些方法可能包括建立按鈕（Button）、文字框（TextBox）等。<br>具體工廠（Concrete Factory）：實現抽象工廠的接口，負責產生具體的產品。每一個具體工廠對應一個具體的產品家族。例如，Windows 工廠負責產生 Windows 風格的按鈕和文字框，而 macOS 工廠則產生 Mac 風格的物件。<br>抽象產品（Abstract Product）：定義產品的接口。這些接口將由具體產品來實現。例如，Button 和 TextBox 分別是兩個不同的抽象產品接口。<br>具體產品（Concrete Product）：實現抽象產品接口的具體類。每一個具體產品都由相應的具體工廠來建立。  </p><h2><span id="抽象工廠模式在gui元件的應用">抽象工廠模式在GUI元件的應用</span></h2><p>假設我們要在需要 Windows 與 Mac 下建立不同平台的按鈕（Button）和文字框（TextBox）。  </p><p>首先我們需要定義這些元件的抽象產品介面，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象產品 Abstract Product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Button() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~TextBox() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們定義一個抽象工廠介面來產生這些GUI元件，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工廠 Abstract Factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Button&gt; createButton() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TextBox&gt; createTextBox() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~GUIFactory() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後我們定義具體產品，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體產品 Concrete Product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsButton</span> :</span> <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Render a Windows style button."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsTextBox</span> :</span> <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Render a Windows style text box."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacButton</span> :</span> <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Render a Mac style button."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacTextBox</span> :</span> <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Render a Mac style text box."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>每個平台會有自己的具體工廠來產生相應風格的GUI元件，我們來定義具體的工廠來產生這些元件，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體工廠 Concrete Factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsGUIFactory</span> :</span> <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Button&gt; createButton() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;WindowsButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TextBox&gt; createTextBox() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;WindowsTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacGUIFactory</span> :</span> <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Button&gt; createButton() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;MacButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TextBox&gt; createTextBox() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;MacTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們可以寫一些客戶端程式碼來產生和使用這些GUI元件，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCode</span><span class="params">(GUIFactory&amp; factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> button = factory.createButton();</span><br><span class="line">    <span class="keyword">auto</span> textBox = factory.createTextBox();</span><br><span class="line"></span><br><span class="line">    button-&gt;render();</span><br><span class="line">    textBox-&gt;render();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WindowsGUIFactory windowsFactory;</span><br><span class="line">    MacGUIFactory macFactory;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Using Windows GUI Factory:\n"</span>;</span><br><span class="line">    clientCode(windowsFactory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Using Mac GUI Factory:\n"</span>;</span><br><span class="line">    clientCode(macFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這段程式碼中，我們只需要告訴客戶端(使用者)使用哪個工廠，它就能夠產生適合該平台的GUI元件，而不需要知道具體的類型。這讓程式碼更加靈活以及容易擴展。  </p><h2><span id="抽象工廠模式的優缺點">抽象工廠模式的優缺點</span></h2><p>抽象工廠模式優點就像一個能夠保持風格統一的工具箱，比如說當你需要開發一個跨平台的應用程式時，它讓你能夠輕鬆地在不同平台之間切換，並確保你的界面風格一致。當你需要支持新的平台或者改變應用的整體外觀風格時，只需要新增一個新的工廠類，現有的程式碼幾乎不需要做任何改動。這種擴展性讓你能夠輕鬆應對未來的需求變化，而不需要擔心系統的核心結構被打亂。</p><p>然而抽象工廠模式也不是沒有缺點的，當你匯入抽象工廠模式後，你的系統架構會變得複雜，特別是當你的專案規模不大時，這種複雜性可能會讓人感覺程式碼變得繁瑣。就好像你本來只需要一個簡單的工具箱，但卻因為引入了這麼多「多功能」工具而變得過於複雜。另外當你想在現有的工廠中新增一個產品類型時，可能會遇到一些困難。你必須去修改所有相關的工廠類，這樣的改動有時候會違背開放封閉原則。這意味著，每當你有新的需求時，你都得花一些時間去調整原本的程式碼，這可能會讓你覺得有些麻煩。  </p><p>整體來說，抽象工廠模式就像是一把雙刃劍，它能夠幫助你打造出一個統一、靈活的系統，但同時也會增加系統的複雜性和維護成本。所以在選擇是否使用這個模式時，還是得根據實際的需求來決定，不要「為了模式而模式」。  </p><h2><span id="抽象工廠模式與工廠方法模式的區別">抽象工廠模式與工廠方法模式的區別</span></h2><p>抽象工廠模式是專注於建立一系列相關聯的產品。適合需要建立整套相關物件（例如一整個產品家族）的場合。  </p><p>工廠方法模式專注於為一個產品家族中的單一產品建立對應的工廠。也就是說如果你只需要產生某一類型的物件（例如按鈕、文字框等），工廠方法模式是理想的選擇。每一個工廠方法只關心如何產生單一類型的產品，而不是整個產品家族。  </p><p>例如在 GUI 開發中，假設你只需要根據不同的平台（Windows 或 Mac）產生特定風格的按鈕，那麼你可以使用工廠方法模式來為每個平台建立對應的按鈕工廠。這樣當你需要一個按鈕時，你只需呼叫對應的工廠方法來取得相應平台的按鈕。  </p><h2><span id="總結">總結</span></h2><p>抽象工廠模式讓我們能夠優雅地管理和組織大型系統中的物件建立過程。在GUI開發中這種模式可以讓我們輕鬆地產生不同平台的元件，還有很多應用場合，例如：特斯拉工廠不僅生產不同的車型，還能生產不同的零組件，比如「標準版」或「高性能版」的輪胎和引擎，或者假設你正在開發一個需要支援多個資料庫（如MySQL、SQL Server、Oracle）的應用程式。每個資料庫有自己特定的連線方式、查詢語法和資料處理方式等等例子，下次當你面對需要建立一系列相關物件的場景時，不妨考慮使用抽象工廠模式。  </p><p><strong>其它相關文章推薦</strong><br>如果你想學習設計模式相關技術，可以參考看看下面的文章，<br><a href="/cpp-simple-factory-pattern/" title="簡單工廠模式 Simple Factory Pattern">簡單工廠模式 Simple Factory Pattern</a><br><a href="/cpp-factory-method-pattern/" title="工廠方法模式 Factory Method Pattern">工廠方法模式 Factory Method Pattern</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在學習設計模式時，你可能會遇到一個問題：「為什麼有這麼多工廠模式？他們到底在解決什麼問題？」工廠方法模式（Factory Method Pattern）提供了一個方法來建立物件，這個方法可以在子類中覆蓋，以便建立不同類型的物件。而抽象工廠模式（Abstract Factor
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 工廠方法模式 Factory Method Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-factory-method-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-factory-method-pattern/</id>
    <published>2024-08-26T12:00:00.000Z</published>
    <updated>2024-09-08T02:40:06.939Z</updated>
    
    <content type="html"><![CDATA[<p>想像你走進一間特斯拉汽車工廠，這裡的工廠並不只是為了生產一款車型，而是可以生產多種不同的車型，像是Model 3、Model Y、Model S、Model X。每個車型雖然都有自己獨特的設計和功能，但它們都有一個共同的特點：它們都是特斯拉生產的。這種情境正好反映了工廠方法模式 Factory Method Pattern 的應用。  </p><h2><span id="什麼是工廠方法模式">什麼是工廠方法模式？</span></h2><p>工廠方法模式是一種建立型設計模式，透過定義一個建立物件的介面來讓子類決定實例化哪一個類別。也就是說工廠方法將物件的建立過程延遲到子類別進行，當我們需要新增車款時，只需建立新的車款子類別，而不必改現有的類別程式碼，從而達成開放封閉原則。在工廠模式中，我們在建立物件時不會對客戶端暴露建立邏輯，而是透過使用一個共同的介面來指向新建立的物件。  </p><p>工廠模式的核心思想是：『把物件的建立過程封裝起來，使得客戶端（使用者）不需要關心具體物件是如何建立的，只需透過工廠來取得所需的物件。』這樣不僅減少了客戶端的複雜度，也增加了系統的靈活性，因為我們可以輕鬆地改變建立物件的方式，而不影響使用者的程式碼。  </p><h2><span id="工廠方法模式在特斯拉汽車工廠的應用">工廠方法模式在特斯拉汽車工廠的應用</span></h2><p>接下來我們將用工廠方法模式來模擬特斯拉工廠如何生產不同的車款。  </p><p>在工廠方法模式中通常會有以下幾個角色：<br>Product（產品）：定義了工廠方法所建立的物件的介面。<br>ConcreteProduct（具體產品）：實現了 Product 介面，具體化了不同車款的類別。<br>Creator（建立者）：宣告了工廠方法，該方法回傳 Product 物件。Creator 的子類別將實現這個方法，  來建立具體的產品物件。<br>ConcreteCreator（具體建立者）：實現 Creator 介面並定義具體工廠方法來建立不同的車款。  </p><p>首先定義一個通用的汽車介面（Product），<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汽車介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Car() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我們為每一款車建立具體產品類別（ConcreteProduct），<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具體產品類別 Model3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model3</span> :</span> <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Driving a Tesla Model 3.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體產品類別 ModelY</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelY</span> :</span> <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Driving a Tesla Model Y.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體產品類別 ModelS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelS</span> :</span> <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Driving a Tesla Model S.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體產品類別 ModelX</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelX</span> :</span> <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Driving a Tesla Model X.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再來定義建立者（Creator）和具體建立者（ConcreteCreator），<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立者介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; createCar() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~CarFactory() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體建立者：Model 3 工廠</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model3Factory</span> :</span> <span class="keyword">public</span> CarFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; createCar() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Model3&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體建立者：Model Y 工廠</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelYFactory</span> :</span> <span class="keyword">public</span> CarFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; createCar() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;ModelY&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體建立者：Model S 工廠</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSFactory</span> :</span> <span class="keyword">public</span> CarFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; createCar() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;ModelS&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具體建立者：Model X 工廠</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelXFactory</span> :</span> <span class="keyword">public</span> CarFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; createCar() override &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;ModelX&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>現在我們可以使用這些工廠來生產不同的車款，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立各個車型的工廠</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CarFactory&gt; model3Factory = <span class="built_in">std</span>::make_unique&lt;Model3Factory&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CarFactory&gt; modelYFactory = <span class="built_in">std</span>::make_unique&lt;ModelYFactory&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CarFactory&gt; modelSFactory = <span class="built_in">std</span>::make_unique&lt;ModelSFactory&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CarFactory&gt; modelXFactory = <span class="built_in">std</span>::make_unique&lt;ModelXFactory&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 產生 Model 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; model3 = model3Factory-&gt;createCar();</span><br><span class="line">    model3-&gt;drive();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 產生 Model Y</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; modelY = modelYFactory-&gt;createCar();</span><br><span class="line">    modelY-&gt;drive();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 產生 Model S</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; modelS = modelSFactory-&gt;createCar();</span><br><span class="line">    modelS-&gt;drive();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 產生 Model X</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Car&gt; modelX = modelXFactory-&gt;createCar();</span><br><span class="line">    modelX-&gt;drive();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在這個範例中每個 CarFactory 子類別負責建立特定車型的汽車，工廠方法 createCar() 回傳一個 Car 物件。這樣的設計讓我們能夠輕鬆地新增或修改車型，而不必更改主程式的邏輯。  </p><p>工廠方法模式最大的體現在於客戶端無需直接接觸實際的產品類別，以這個例子為例，客戶端不需直接去 new Model3 這個 class，這個 Model3 class 就放在工廠內部的實現就好，這樣解耦客戶端與具體產品類別之間的依賴關係。這樣客戶端的程式碼不會因為產品類別的改變而受到影響，這就是工廠方法模式提供的高度靈活性和可擴展性。  </p><h2><span id="工廠方法模式的優缺點">工廠方法模式的優缺點</span></h2><p>工廠方法模式有不少好處，像是當我們需要新增車款時，不需要動到現有的程式碼，只需新增一個相應的工廠類別就可以了，這樣一來系統變得更靈活，也更符合開放封閉原則。另外工廠方法模式還能讓產品的產生與使用分離開來，這樣做的好處是減少了系統內部的耦合，讓程式碼更容易維護和擴展。  </p><p>工廠方法模式也有它的缺點。因為每新增一款車，就要寫一個新的工廠類別，久而久之類別的數量會不斷增加，讓程式碼結構變得複雜，管理起來也會變得麻煩。這樣的代價在某些系統中可能會造成不便，特別是當產品種類多而需求變化頻繁的時候。  </p><p>工廠方法模式在需要靈活建立不同產品的系統中非常有用，但也需要考慮到它可能帶來的複雜性，衡量是否適合使用。  </p><h2><span id="工廠方法模式-vs-簡單工廠模式">工廠方法模式 vs. 簡單工廠模式</span></h2><p>工廠方法模式（Factory Method Pattern）和簡單工廠模式（Simple Factory Pattern）都是用來建立物件的設計模式，但它們在結構和適用範圍上有所不同。以下是它們的主要差異：  </p><p>簡單工廠模式不是正式的設計模式（而是一種設計理念），它由一個工廠類別負責根據給定的參數建立不同類型的物件。這個工廠類別包含了一個靜態方法（或全域方法）來根據需要建立物件。  </p><p>簡單工廠模式特點是只有一個工廠類別，這個工廠類別根據參數決定實例化哪個具體類別。簡單工廠模式擴展困難，當需要增加新的產品類型時，需要修改工廠類別的程式碼，這會違背開放封閉原則。適合簡單的需求和少量的產品類型。  </p><p>工廠方法模式定義了一個建立物件的介面，但讓子類決定具體實例化哪個類別。這樣可以透過擴展工廠方法來支持新類型，而不需要修改已有程式碼。  </p><p>工廠方法模式特點是多個工廠，每個具體工廠子類負責建立特定類型的物件。工廠方法模式將物件建立的邏輯分散到多個子工廠中。工廠方法模式新增產品類型只需要增加新的工廠子類，不需要修改現有的工廠類別。符合開放封閉原則，可以透過擴展工廠子類來支持新的產品，而不改動現有的程式碼。  </p><h2><span id="總結">總結</span></h2><p>工廠方法模式它允許我們根據需求建立不同的產品物件。在這篇文章中我們透過特斯拉汽車工廠的範例，展示了如何使用工廠方法模式來靈活地產生 Model 3、Model Y、Model S 和 Model X 等不同的車款。這種模式不僅提高了系統的靈活性和可擴展性，還降低了系統的耦合度。  </p><p>設計模式是解決問題的工具，而不是目的本身。靈活運用才能寫出真正優雅且實用的程式碼。就像一個熟練的廚師，知道何時使用何種工具來製作最美味的菜餚，一個優秀的程式設計師也應該知道何時使用何種設計模式來創造出最優雅的程式碼。  </p><p><strong>其它相關文章推薦</strong><br>如果你想學習設計模式相關技術，可以參考看看下面的文章，<br><a href="/cpp-abstract-factory-pattern/" title="抽象工廠模式 Abstract Factory Pattern">抽象工廠模式 Abstract Factory Pattern</a><br><a href="/cpp-simple-factory-pattern/" title="簡單工廠模式 Simple Factory Pattern">簡單工廠模式 Simple Factory Pattern</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想像你走進一間特斯拉汽車工廠，這裡的工廠並不只是為了生產一款車型，而是可以生產多種不同的車型，像是Model 3、Model Y、Model S、Model X。每個車型雖然都有自己獨特的設計和功能，但它們都有一個共同的特點：它們都是特斯拉生產的。這種情境正好反映了工廠方法
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 樣板方法模式 Template Method Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-template-method-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-template-method-pattern/</id>
    <published>2024-08-25T12:00:00.000Z</published>
    <updated>2024-09-03T13:30:07.672Z</updated>
    
    <content type="html"><![CDATA[<p>在資料分析領域中，我們需要從海量的資料中提取有價值的資訊。但是面對不同格式的資料，例如：XML、CSV、JSON 等格式，我們該如何設計一個靈活又高效的分析工具呢？然而不論資料格式種類不同，分析的步驟通常是相似的，今天讓我們一起來探討設計模式中的樣板方法模式 Template Method Pattern ，看看它如何幫助我們解決這個問題。  </p><h2><span id="什麼是樣板方法模式">什麼是樣板方法模式？</span></h2><p>樣板方法模式是一種行為設計模式，它在一個方法中定義了一個演算法的骨架，而將一些通用步驟的實作延遲到子類中。樣板方法使得子類可以在不改變演算法結構的情況下，重新定義演算法中的某些步驟的內容。換句話說，樣板方法確保了演算法的骨架（例如流程的步驟）是一致的，但細節部分可以由不同的子類自行定義。  </p><p>聽起來有點抽象？別擔心，讓我們用一個生活中的例子來解釋。  </p><p>想像你在煮一鍋湯。無論你煮的是什麼湯，基本步驟都是相似的：  </p><ol><li>準備食材</li><li>加水並煮沸</li><li>加入主要食材</li><li>調味</li><li>盛盤</li></ol><p>這個流程就是一個「樣板方法」。不同的湯可能在食材準備和調味方式上有所不同，但整體流程是一致的。  </p><h2><span id="樣板方法模式資料分析工具的應用">樣板方法模式資料分析工具的應用</span></h2><p>回到資料分析的情景，假設我們正在開發一個資料分析工具，這個工具可以讀取不同格式的資料（XML、CSV、JSON），並產生分析報告。無論資料來源為何，我們的分析流程大致相同，包括讀取資料、分析資料、生成報告。  </p><p>我們可以定義一個 <code>DataAnalyzer</code> 基類，來統一處理通用的分析步驟，但將具體的資料讀取方式交給子類別來實作。  </p><p>首先，定義 <code>DataAnalyzer</code> 基類，其中包含了樣板方法 <code>analyze()</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataAnalyzer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">analyze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readData();</span><br><span class="line">        processData();</span><br><span class="line">        generateReport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~DataAnalyzer() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 抽象方法，由子類別實作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Processing data..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 通用的資料處理邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Generating report..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 通用的報告生成邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著，我們可以為每種資料格式建立不同的子類別，並各自實作 <code>readData()</code> 方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLDataAnalyzer</span> :</span> <span class="keyword">public</span> DataAnalyzer &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading data from XML file..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 具體的 XML 資料讀取邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSVDataAnalyzer</span> :</span> <span class="keyword">public</span> DataAnalyzer &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading data from CSV file..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 具體的 CSV 資料讀取邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONDataAnalyzer</span> :</span> <span class="keyword">public</span> DataAnalyzer &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading data from JSON file..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 具體的 JSON 資料讀取邏輯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>當我們使用這些子類別時，無需擔心具體的資料讀取邏輯，只需關注分析流程的整體結構，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataAnalyzer&gt; analyzer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    analyzer-&gt;analyze();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;XMLDataAnalyzer&gt; xmlAnalyzer = <span class="built_in">std</span>::make_unique&lt;XMLDataAnalyzer&gt;();</span><br><span class="line">    ClientCode(<span class="built_in">std</span>::move(xmlAnalyzer)); <span class="comment">// 分析 XML 資料</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataAnalyzer&gt; csvAnalyzer =  <span class="built_in">std</span>::make_unique&lt;CSVDataAnalyzer&gt;();</span><br><span class="line">    ClientCode(<span class="built_in">std</span>::move(csvAnalyzer)); <span class="comment">// 分析 CSV 資料</span></span><br><span class="line"></span><br><span class="line">    ClientCode(<span class="built_in">std</span>::make_unique&lt;JSONDataAnalyzer&gt;()); <span class="comment">// 分析 JSON 資料</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reading data from XML file...</span><br><span class="line">Processing data...</span><br><span class="line">Generating report...</span><br><span class="line">Reading data from CSV file...</span><br><span class="line">Processing data...</span><br><span class="line">Generating report...</span><br><span class="line">Reading data from JSON file...</span><br><span class="line">Processing data...</span><br><span class="line">Generating report...</span><br></pre></td></tr></table></figure></p><p>在這個範例中，我們展示了如何使用樣板方法模式來處理不同資料格式的分析流程。透過定義通用的分析步驟，我們確保了分析邏輯的一致性，同時又保留了靈活性，讓我們可以根據實際不同需求來實作對應的資料讀取方式。</p><h2><span id="樣板方法模式的優點">樣板方法模式的優點</span></h2><p>樣板方法模式的優點如下，主要優勢在於統一流程和靈活擴展，  </p><ul><li>程式碼複用性：將通用的分析步驟寫在基類中，避免了在每個子類別中重複寫相同的邏輯。  </li><li>靈活與擴展性：可以輕鬆添加新的資料格式，只需建立新的子類別並實現對應的讀取方法，而不需要改變整體的分析流程。  </li><li>容易維護：分析流程的改動只需修改基類，而不需要修改每個子類別，這使得系統更加易於維護。  </li></ul><h2><span id="總結">總結</span></h2><p>樣板方法模式在軟體開發中，就像是一個烹飪配方，固定的步驟確保了整體的流程不會亂套，而細節上的變化則由各種料理的需求來決定。這樣的設計不僅讓程式更具結構性，也讓開發者能夠輕鬆地應對需求的變更或擴展。如果你在日常的開發工作中需要處理類似的問題，不妨考慮使用樣板方法模式來優雅地解決。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在資料分析領域中，我們需要從海量的資料中提取有價值的資訊。但是面對不同格式的資料，例如：XML、CSV、JSON 等格式，我們該如何設計一個靈活又高效的分析工具呢？然而不論資料格式種類不同，分析的步驟通常是相似的，今天讓我們一起來探討設計模式中的樣板方法模式 Templat
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>PHP base64_encode 編碼使用指南：方法與應用</title>
    <link href="https://shengyu7697.github.io/php-base64_encode/"/>
    <id>https://shengyu7697.github.io/php-base64_encode/</id>
    <published>2024-08-24T12:00:00.000Z</published>
    <updated>2024-06-18T00:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇 ShengYu 介紹 PHP base64_encode 用法與範例，在 PHP 開發中，<code>base64_encode</code> 是一個常用的函式，它可以將二進位資料轉換為 ASCII 字串。這種編碼方式特別適合在需要傳輸或儲存二進位資料的情況下使用。本文將介紹 <code>base64_encode</code> 的基本用法及其在不同場景中的應用。</p><h2><span id="什麼是-base64-編碼">什麼是 Base64 編碼？</span></h2><p>Base64 是一種將二進位資料編碼為 ASCII 字串的方式。它將資料轉換為僅包含字母、數字、加號和斜杠的字元，以及等號 <code>=</code> 作為填充符。這種編碼可以安全地在 URL 和電子郵件中使用，因為它不會引起轉義問題。</p><h2><span id="base64_encode-函式的基本用法"><code>base64_encode</code> 函式的基本用法</span></h2><p>在 PHP 中，<code>base64_encode</code> 函式用於將資料編碼為 Base64 格式。以下是其基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string base64_encode ( string $data )</span><br></pre></td></tr></table></figure><ul><li><strong>參數：</strong> <code>$data</code> 是需要編碼的資料，通常是字串形式。</li><li><strong>回傳值：</strong> 回傳 Base64 編碼後的字串。</li></ul><h2><span id="範例">範例</span></h2><p>以下是一個簡單的範例，展示如何使用 <code>base64_encode</code> 將字串編碼為 Base64 格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 原始資料</span></span><br><span class="line">$data = <span class="string">"Hello, World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將資料編碼為 Base64</span></span><br><span class="line">$encodedData = base64_encode($data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 輸出編碼後的結果</span></span><br><span class="line"><span class="keyword">echo</span> $encodedData; <span class="comment">// 輸出：SGVsbG8sIFdvcmxkIQ==</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在這個範例中，我們將字串 “Hello, World!” 編碼為 Base64 格式，結果為 “SGVsbG8sIFdvcmxkIQ==”.</p><h2><span id="base64-編碼的應用場景">Base64 編碼的應用場景</span></h2><ol><li><strong>在 URL 中傳輸資料：</strong> 由於 Base64 編碼的結果僅包含 URL 安全的字元，因此可以安全地用於 URL 中，而不會引起轉義問題。</li><li><strong>儲存二進位資料：</strong> 在需要將圖片或其他二進位檔案儲存到資料庫時，可以先將其編碼為 Base64 格式。</li><li><strong>電子郵件：</strong> 在 MIME 電子郵件中，Base64 常用於編碼附件，以確保二進位資料在傳輸過程中不會被損壞。</li></ol><h2><span id="補充">補充</span></h2><p>若需要將 Base64 編碼的資料解碼回原始格式，可以使用 <code>base64_decode</code> 函式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$decodedData = base64_decode($encodedData);</span><br><span class="line"><span class="keyword">echo</span> $decodedData; <span class="comment">// 輸出：Hello, World!</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="結論">結論</span></h2><p><code>base64_encode</code> 是 PHP 中非常實用的一個函式，尤其在需要安全傳輸或儲存二進位資料時。透過本文的介紹，希望你能夠更好地理解和應用這個函式，提升你的 PHP 開發效率。</p><p>以上就是 PHP base64_encode 用法與範例介紹，<br>如果你覺得我的文章寫得不錯、對你有幫助的話記得 <a href="https://www.facebook.com/shengyu7697/" rel="noopener" target="_blank">Facebook 按讚</a>支持一下！  </p><p><strong>其它相關文章推薦</strong><br>如果你想學習 PHP 相關技術，可以參考看看下面的文章，<br><a href="/php-pdo/" title="PHP 和 PDO 進行資料庫操作">PHP 和 PDO 進行資料庫操作</a><br><a href="/php-display-errors/" title="PHP 執行發生錯誤在 Chrome/Firefox 上顯示 Error 500，要怎麼讓 PHP 顯示錯誤">PHP 執行發生錯誤在 Chrome/Firefox 上顯示 Error 500，要怎麼讓 PHP 顯示錯誤</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇 ShengYu 介紹 PHP base64_encode 用法與範例，在 PHP 開發中，&lt;code&gt;base64_encode&lt;/code&gt; 是一個常用的函式，它可以將二進位資料轉換為 ASCII 字串。這種編碼方式特別適合在需要傳輸或儲存二進位資料的情況下使用。本
      
    
    </summary>
    
      <category term="PHP教學" scheme="https://shengyu7697.github.io/categories/PHP%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="PHP" scheme="https://shengyu7697.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 裝飾者模式 Decorator Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-decorator-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-decorator-pattern/</id>
    <published>2024-08-23T12:00:00.000Z</published>
    <updated>2024-08-28T13:30:08.453Z</updated>
    
    <content type="html"><![CDATA[<p>在日常生活中，我們經常會去咖啡店買咖啡，但如果想要來點變化，像是加一點牛奶或糖，就可以讓平凡的咖啡多一點風味。同樣地，在程式設計中，我們有時也需要在不改變原有功能的前提下，為某些物件「加點料」。這就是裝飾者模式 Decorator Pattern 所要解決的問題。  </p><h2><span id="什麼是裝飾者模式">什麼是裝飾者模式？</span></h2><p>裝飾者模式是一種結構型設計模式，它允許你動態地為物件添加功能，而不需要修改其原有的程式碼。換句話說，裝飾者模式讓你可以根據不同的需求，隨時為一個物件「增添佐料」，就像你為咖啡加牛奶或糖一樣，都會改變咖啡的口感和價格，但我們並沒有改變咖啡本身。  </p><h2><span id="裝飾者模式在咖啡店的應用">裝飾者模式在咖啡店的應用</span></h2><p>讓我們用一個簡單的例子來說明。假設我們有一個基本的咖啡類別 <code>Coffee</code>，它代表一杯不加任何配料的黑咖啡。你可以根據需求選擇加入牛奶、糖或其他配料。使用裝飾者模式，我們可以輕鬆地計算出各種組合的價格，而不需要為每種可能的組合建立新的類別。  </p><p>首先，我們定義一個 <code>Coffee</code> 類別，並為它計算基本價錢的功能：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"黑咖啡"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Coffee() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>假設你想在咖啡中加牛奶，我們可以建立一個裝飾者類別 <code>MilkDecorator</code>，這個類別將會裝飾（也就是包裝）<code>Coffee</code> 類別，並在其基礎上增加牛奶的功能：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkDecorator</span> :</span> <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Coffee&gt; coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MilkDecorator(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Coffee&gt; c) : coffee(<span class="built_in">std</span>::move(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;getDescription() + <span class="string">"+牛奶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;cost() + <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果你想再加點糖，可以再建立一個 <code>SugarDecorator</code> 類別：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarDecorator</span> :</span> <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Coffee&gt; coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SugarDecorator(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Coffee&gt; c) : coffee(<span class="built_in">std</span>::move(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;getDescription() + <span class="string">"+糖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee-&gt;cost() + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後我們就可以根據自己的需求自由組合這些裝飾者：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Coffee&gt; coffee = <span class="built_in">std</span>::make_unique&lt;Coffee&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; coffee-&gt;getDescription() &lt;&lt; <span class="string">"價格："</span></span><br><span class="line">              &lt;&lt; coffee-&gt;cost() &lt;&lt; <span class="string">"元\n"</span>;</span><br><span class="line">    coffee = <span class="built_in">std</span>::make_unique&lt;MilkDecorator&gt;(<span class="built_in">std</span>::move(coffee));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; coffee-&gt;getDescription() &lt;&lt; <span class="string">"價格："</span></span><br><span class="line">              &lt;&lt; coffee-&gt;cost() &lt;&lt; <span class="string">"元\n"</span>;</span><br><span class="line">    coffee = <span class="built_in">std</span>::make_unique&lt;SugarDecorator&gt;(<span class="built_in">std</span>::move(coffee));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; coffee-&gt;getDescription() &lt;&lt; <span class="string">"價格："</span></span><br><span class="line">              &lt;&lt; coffee-&gt;cost() &lt;&lt; <span class="string">"元\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑咖啡價格：50元</span><br><span class="line">黑咖啡+牛奶價格：65元</span><br><span class="line">黑咖啡+牛奶+糖價格：70元</span><br></pre></td></tr></table></figure></p><p>在這個範例中，我們從一杯基本的黑咖啡開始，然後動態地添加牛奶和糖，最終計算出一杯加了牛奶和糖的咖啡價格。每次添加新配料時，我們不需要修改現有的咖啡類別，只需透過裝飾者來實現功能的擴展。這樣的設計讓我們可以靈活地擴展功能，也讓程式碼更加易於維護。  </p><h2><span id="裝飾者模式的優點">裝飾者模式的優點</span></h2><p>裝飾者模式的最大優點就是靈活性，你可以任意組合裝飾者成各種不同的組合。當你面對需要不斷添加新功能的情況時，使用裝飾者模式可以避免類別數量的膨脹，讓程式碼更易於維護和擴展。同時它也保持了開放封閉原則，也就是添加新的裝飾者不需要修改原始類別，也符合單一職責原則，即每個裝飾者只負責一項特定的功能增強。  </p><h2><span id="總結">總結</span></h2><p>裝飾者模式就像是在咖啡裡添加牛奶和糖，讓原本簡單的東西變得更加豐富多樣。在程式設計中，它能幫助我們以一種靈活的方式，擴展物件的功能，同時保持程式碼的清晰與可維護性。下次當你面臨需要擴展物件功能的需求時，考慮一下裝飾者模式，它或許就是你需要的解決方案！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常生活中，我們經常會去咖啡店買咖啡，但如果想要來點變化，像是加一點牛奶或糖，就可以讓平凡的咖啡多一點風味。同樣地，在程式設計中，我們有時也需要在不改變原有功能的前提下，為某些物件「加點料」。這就是裝飾者模式 Decorator Pattern 所要解決的問題。  &lt;/p
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 觀察者模式 Observer Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-observer-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-observer-pattern/</id>
    <published>2024-08-22T12:00:00.000Z</published>
    <updated>2024-08-27T14:30:07.001Z</updated>
    
    <content type="html"><![CDATA[<p>今天你訂閱了一個喜歡的 YouTube 頻道，這個頻道一旦有新影片發布，你就會收到通知。不需要你反覆檢查頻道是否有新內容，所有更新自動發送到你手上。在軟體開發中，我們常常需要處理這樣的情境，當一個物件的狀態發生變化時，其他相關物件需要自動更新，並做出相應的回應。這種情境下我們就可以運用觀察者模式 Observer Pattern。  </p><h2><span id="什麼是觀察者模式">什麼是觀察者模式？</span></h2><p>觀察者模式是一種行為設計模式，它定義了一種一對多的依賴關係，當一個物件（被觀察者）發生改變時，所有依賴它的物件（觀察者）都會自動收到通知並更新自己。這讓系統中的物件之間能夠鬆散耦合，保持靈活性和可維護性。  </p><h2><span id="觀察者模式在-youtube-訂閱的應用">觀察者模式在 YouTube 訂閱的應用</span></h2><p>在這個範例中，我們將 YouTube 頻道視為「被觀察者」，訂閱該頻道的使用者則是「觀察者」。當頻道有新影片上傳時，所有訂閱者都會自動收到通知。讓我們用 C++ 來實踐這個概念。  </p><p>我們定義一個 <code>Observer</code> 介面，所有的觀察者（訂閱者）都要實作這個介面。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; videoTitle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Observer() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接著我們定義一個 <code>Subject</code> 介面，讓被觀察者（YouTube 頻道）管理觀察者的訂閱和通知。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Observer&gt; observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Observer&gt; observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Subject() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下來我們實作一個具體的 <code>YouTubeChannel</code> 類別，這個類別代表 YouTube 頻道，當有新影片發布時，它會通知所有的訂閱者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YouTubeChannel</span> :</span> <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Observer&gt;&gt; subscribers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> latestVideo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Observer&gt; observer)</span> override </span>&#123;</span><br><span class="line">        subscribers.push_back(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Observer&gt; observer)</span> override </span>&#123;</span><br><span class="line">        subscribers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observer : subscribers) &#123;</span><br><span class="line">            observer-&gt;update(latestVideo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uploadNewVideo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; videoTitle)</span> </span>&#123;</span><br><span class="line">        latestVideo = videoTitle;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最後我們可以定義多個觀察者來代表不同的訂閱者，他們會在接收到新影片通知時，顯示影片的標題。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> :</span> <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Subscriber(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; videoTitle)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" received notification: "</span> </span><br><span class="line">            &lt;&lt; videoTitle &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>當我們將 <code>Subscriber</code> 加入 <code>YouTubeChannel</code> 的訂閱者清單時，頻道一旦上傳新影片，所有的訂閱者都會自動收到通知。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    YouTubeChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Subscriber&gt; alice = <span class="built_in">std</span>::make_shared&lt;Subscriber&gt;(<span class="string">"Alice"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Subscriber&gt; bob = <span class="built_in">std</span>::make_shared&lt;Subscriber&gt;(<span class="string">"Bob"</span>);</span><br><span class="line"></span><br><span class="line">    channel.addObserver(alice);</span><br><span class="line">    channel.addObserver(bob);</span><br><span class="line">    channel.uploadNewVideo(<span class="string">"First Video"</span>);</span><br><span class="line"></span><br><span class="line">    channel.removeObserver(bob);</span><br><span class="line">    channel.uploadNewVideo(<span class="string">"Second Video"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行上述程式碼，我們會得到以下輸出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice received notification: First Video</span><br><span class="line">Bob received notification: First Video</span><br><span class="line">Alice received notification: Second Video</span><br></pre></td></tr></table></figure></p><p>這個範例中使用了觀察者模式來模擬 YouTube 訂閱系統。當 YouTube 頻道上傳新影片時，所有的訂閱者都會自動收到通知。這讓我們的系統能夠更靈活地應對訂閱和通知的需求。  </p><h2><span id="觀察者模式的優點">觀察者模式的優點</span></h2><p>以這個例子來說，使用觀察者模式降低了耦合度，訂閱者和 YouTube 頻道之間的關係是鬆散的，YouTube 頻道不需要知道實際上是誰訂閱了它，它只需要通知所有訂閱者，這讓系統更容易擴展跟維護。  </p><p>同時也具備擴展性，你可以輕鬆地新增或移除訂閱者，而不需要修改 YouTube 頻道的程式碼。  </p><h2><span id="總結">總結</span></h2><p>觀察者模式是一種常見的設計模式，能有效處理多個物件之間的通知和更新需求。在我們生活中無所不在，例如：股票價格變化時，關注該股票的投資者都會收到通知，天氣變化時，訂閱天氣服務的使用者都會收到更新，電子報發布時，訂閱的讀者也會收到信件。下次你在設計系統時，如果遇到一對多的依賴關係，並且希望它們能夠自動更新的情況，不妨試試觀察者模式！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天你訂閱了一個喜歡的 YouTube 頻道，這個頻道一旦有新影片發布，你就會收到通知。不需要你反覆檢查頻道是否有新內容，所有更新自動發送到你手上。在軟體開發中，我們常常需要處理這樣的情境，當一個物件的狀態發生變化時，其他相關物件需要自動更新，並做出相應的回應。這種情境下我
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式 - 策略模式 Strategy Pattern</title>
    <link href="https://shengyu7697.github.io/cpp-strategy-pattern/"/>
    <id>https://shengyu7697.github.io/cpp-strategy-pattern/</id>
    <published>2024-08-21T12:00:00.000Z</published>
    <updated>2024-08-26T14:50:06.841Z</updated>
    
    <content type="html"><![CDATA[<p>在日常開發中，我們常需要對檔案進行壓縮，而不同的壓縮格式（如 Zip、Rar、7z 等）各有其優缺點。有時候我們希望能夠根據當下需求自由地切換壓縮方式，而不需要改動太多的程式碼。這時候策略模式 Strategy Pattern 就可以幫我們輕鬆實現這個需求。  </p><h2><span id="什麼是策略模式">什麼是策略模式？</span></h2><p>策略模式是一種行為設計模式，它可以讓我們定義一系列的演算法，將每個演算法封裝起來，並讓它們可以互相替換使用。這樣一來程式碼不僅更加靈活，也更容易擴展跟維護了。  </p><p>簡單來說，策略模式就是讓程式可以隨意更換的「策略」，讓程式能夠靈活地應對不同種的情況。  </p><h2><span id="策略模式在壓縮器中的應用">策略模式在壓縮器中的應用</span></h2><p>假設你正在開發一個檔案壓縮的功能。一開始你可能只支援 ZIP 格式壓縮。但隨著使用者需求的增加，你發現需要添加 RAR、7Z 等其他壓縮格式的支援。  </p><p>你的程式碼可能會寫成這樣：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; format)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (format == <span class="string">"zip"</span>) &#123;</span><br><span class="line">            <span class="comment">// ZIP 壓縮邏輯</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == <span class="string">"rar"</span>) &#123;</span><br><span class="line">            <span class="comment">// RAR 壓縮邏輯</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == <span class="string">"7z"</span>) &#123;</span><br><span class="line">            <span class="comment">// 7Z 壓縮邏輯</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"不支援的格式"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>這種方法的問題在於每次新增新的壓縮格式時，都需要修改 Compressor 類別。這違反了「開放封閉原則」，也就是軟體應該對擴展開放，對修改封閉。  </p><p>讓我們看看如何使用策略模式來改進這個設計：  </p><p>我們先定義一個壓縮策略介面 CompressionStrategy，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressionStrategy</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~CompressionStrategy() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後為每種壓縮格式實作具體的策略，分別為 ZipStrategy、RarStrategy、SevenZipStrategy，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipStrategy</span> :</span> <span class="keyword">public</span> CompressionStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用 ZIP 壓縮 "</span> &lt;&lt; filename &lt;&lt; <span class="string">" 檔案\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RarStrategy</span> :</span> <span class="keyword">public</span> CompressionStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用 RAR 壓縮 "</span> &lt;&lt; filename &lt;&lt; <span class="string">" 檔案\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SevenZipStrategy</span> :</span> <span class="keyword">public</span> CompressionStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用 7Z 壓縮 "</span> &lt;&lt; filename &lt;&lt; <span class="string">" 檔案\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>根據此情境在設計時，建立一個 Compressor 壓縮器，又為稱上下文類別，這個 Compressor 類別可以根據需求動態選擇不同的壓縮策略。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CompressionStrategy&gt; strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Compressor(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CompressionStrategy&gt; strategy) </span><br><span class="line">        : strategy(<span class="built_in">std</span>::move(strategy)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CompressionStrategy&gt; newStrategy)</span> </span>&#123;</span><br><span class="line">        strategy = <span class="built_in">std</span>::move(newStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span> </span>&#123;</span><br><span class="line">        strategy-&gt;compress(filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>當需要使用壓縮器時，可以這樣寫，Compressor 將會執行已經選擇的壓縮策略進行壓縮，然後也可以執行期間更換壓縮策略，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Compressor <span class="title">compressor</span><span class="params">(<span class="built_in">std</span>::make_unique&lt;ZipStrategy&gt;())</span></span>;</span><br><span class="line">    compressor.compress(<span class="string">"file1.txt"</span>);  <span class="comment">// 輸出：使用 ZIP 壓縮 file1.txt 檔案</span></span><br><span class="line"></span><br><span class="line">    compressor.setStrategy(<span class="built_in">std</span>::make_unique&lt;SevenZipStrategy&gt;());</span><br><span class="line">    compressor.compress(<span class="string">"file2.txt"</span>);  <span class="comment">// 輸出：使用 7Z 壓縮 file2.txt 檔案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="策略模式的優點">策略模式的優點</span></h2><p>使用策略模式，讓我們能夠方便地擴展壓縮器的功能，當需要增加新的壓縮格式時，只需新增一個實作了 CompressionStrategy 介面，並將其設定到 Compressor 中即可，完全不需要修改現有 Compressor 與其它壓縮策略的程式碼。另外策略模式還能讓程式碼變得更加清晰易懂，避免大量的條件判斷或分支邏輯，使系統在面對複雜業務需求時，依然能保持穩定和易於維護。  </p><h2><span id="總結">總結</span></h2><p>策略模式是一個很實用的設計模式，能夠有效解決系統中某些功能需要頻繁變動或擴展的問題。在這個壓縮器範例中，我們看到如何使用策略模式來靈活地切換壓縮格式，並保持程式碼的清晰和可維護性。並能在日後的開發中靈活運用它，讓你的程式碼更加優雅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常開發中，我們常需要對檔案進行壓縮，而不同的壓縮格式（如 Zip、Rar、7z 等）各有其優缺點。有時候我們希望能夠根據當下需求自由地切換壓縮方式，而不需要改動太多的程式碼。這時候策略模式 Strategy Pattern 就可以幫我們輕鬆實現這個需求。  &lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ 設計模式入門：什麼是設計模式？為什麼要學習它們？</title>
    <link href="https://shengyu7697.github.io/cpp-design-patterns/"/>
    <id>https://shengyu7697.github.io/cpp-design-patterns/</id>
    <published>2024-08-20T12:00:00.000Z</published>
    <updated>2024-09-11T00:10:07.594Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="設計模式入門什麼是設計模式為什麼要學習它們">設計模式入門：什麼是設計模式？為什麼要學習它們？</span></h2><p>當聽到「設計模式」這個詞時，可能會覺得這是什麼複雜寫程式的技術或者高深的專業知識。但實際上設計模式是一種能讓我們能夠寫出更好、更靈活程式的一套方法，不是專屬於高手的工具，反而是所有開發者都應該掌握的基礎。  </p><h2><span id="什麼是設計模式">什麼是設計模式？</span></h2><p>設計模式其實是一組解決特定問題的經驗法則和最佳實踐。它們就像是軟體設計中的藍圖，你可以用它們來解決程式碼中反復出現的設計問題。換句話說，設計模式不是要讓你重新發明輪子，而是告訴你輪子怎麼樣做才能又快又穩。  </p><p>假如你正在建造一座房子。你不會每次都從零開始設計門或窗戶對吧？你會使用已經被證明有效的設計。設計模式在軟體開發中的作用就像這些可重用的建築元素。  </p><h2><span id="為什麼要學習設計模式">為什麼要學習設計模式？</span></h2><p>學習設計模式的目的不僅僅是為了寫出漂亮的程式碼或者通過面試，更重要的是它能讓你在面對複雜問題時，有一套成熟的方法來應對。  </p><p>你可能會問：「為什麼不直接寫程式呢？為什麼要花時間學習這些理論？」原因在於，當你寫程式寫得越久，你會發現自己常常面對相似的問題。如果每次都從零開始解決這些問題，不僅耗時還容易出錯。而設計模式正是經過專家長久時間驗證淬鍊的解決方案，能幫助你更快地找到正確的方向。  </p><p>學習設計模式有以下幾點好處：  </p><ol><li>提高程式碼質量：設計模式提供了經過時間考驗的解決方案，可以幫助你寫出更清晰、更容易維護的程式碼。  </li><li>加快開發速度：一旦你熟悉了常見的設計模式，你就可以更快識別問題並實作解決方案，而不是每次都重新造輪子。  </li><li>促進團隊合作：為開發者提供了一種共同語言。當你說『我們這裡可以用觀察者模式』時，懂設計模式的同事馬上就能了解你的意思。  </li><li>應對軟體變化：好的設計模式能讓你的程式碼更容易適應變化。在軟體開發中，變化是唯一不變的東西！  </li><li>學習優秀的實踐設計：學習設計模式不僅是學習具體的解決方案，更是學習如何思考和解決問題。  </li></ol><p>讓我們開始掌握設計模式，成為一個更有智慧的開發者吧。  </p><p><strong>建立行模式(5)</strong>  </p><ul><li><a href="/cpp-factory-method-pattern/" title="工廠方法模式 Factory Method Pattern：動態決定物件的類型">工廠方法模式 Factory Method Pattern：動態決定物件的類型</a>  </li><li><a href="/cpp-abstract-factory-pattern/" title="抽象工廠模式 Abstract Factory Pattern：建立系列相關物件">抽象工廠模式 Abstract Factory Pattern：建立系列相關物件</a>  </li><li><a href="/cpp-builder-pattern/" title="建造者模式 Builder Pattern：分步驟建立複雜物件">建造者模式 Builder Pattern：分步驟建立複雜物件</a>  </li><li>原型模式 Prototype Pattern：複製物件而非重新建立  </li><li><a href="/cpp-singleton-pattern/" title="單例模式 Singleton Pattern：確保類別只有一個實例">單例模式 Singleton Pattern：確保類別只有一個實例</a>  </li></ul><p><strong>結構型模式(7)</strong>  </p><ul><li><a href="/cpp-adapter-pattern/" title="轉接器模式 Adapter Pattern：包裝物件提供不同的接口">轉接器模式 Adapter Pattern：包裝物件提供不同的接口</a>  </li><li>橋接模式 Bridge Pattern：分離抽象與實現  </li><li><a href="/cpp-composite-pattern/" title="組合模式 Composite Pattern：樹形結構處理">組合模式 Composite Pattern：樹形結構處理</a>  </li><li><a href="/cpp-decorator-pattern/" title="裝飾者模式 Decorator Pattern：動態新增功能">裝飾者模式 Decorator Pattern：動態新增功能</a>  </li><li><a href="/cpp-facade-pattern/" title="門面模式 Facade Pattern：簡化接口">門面模式 Facade Pattern：簡化接口</a>  </li><li>享元模式 Flyweight Pattern：共享物件以節省記憶體  </li><li><a href="/cpp-proxy-pattern/" title="代理模式 Proxy Pattern：控制物件的訪問">代理模式 Proxy Pattern：控制物件的訪問</a>  </li></ul><p><strong>行為模式(11)</strong>  </p><ul><li>  </li><li><a href="/cpp-command-pattern/" title="命令模式 Command Pattern：封裝請求為物件">命令模式 Command Pattern：封裝請求為物件</a>  </li><li><a href="/cpp-iterator-pattern/" title="迭代器模式 Iterator Pattern：遍歷集合物件">迭代器模式 Iterator Pattern：遍歷集合物件</a>  </li><li><a href="/cpp-mediator-pattern/" title="中介者模式 Mediator Pattern：簡化物件間的通訊">中介者模式 Mediator Pattern：簡化物件間的通訊</a>  </li><li><a href="/cpp-memento-pattern/" title="備忘錄模式 Memento Pattern：保存物件狀態">備忘錄模式 Memento Pattern：保存物件狀態</a>  </li><li><a href="/cpp-observer-pattern/" title="觀察者模式 Observer Pattern：事件通知機制">觀察者模式 Observer Pattern：事件通知機制</a>  </li><li><a href="/cpp-state-pattern/" title="狀態模式 State Pattern：根據狀態改變行為">狀態模式 State Pattern：根據狀態改變行為</a>  </li><li><a href="/cpp-strategy-pattern/" title="策略模式 Strategy Pattern：動態改變演算法">策略模式 Strategy Pattern：動態改變演算法</a>  </li><li><a href="/cpp-template-method-pattern/" title="樣板方法模式 Template Method Pattern：定義演算法框架">樣板方法模式 Template Method Pattern：定義演算法框架</a>  </li><li>訪問者模式 Visitor Pattern：新增操作而不改變物件結構  </li><li>解釋器模式 Interpreter Pattern：語言解析器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;設計模式入門什麼是設計模式為什麼要學習它們&quot;&gt;設計模式入門：什麼是設計模式？為什麼要學習它們？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;當聽到「設計模式」這個詞時，可能會覺得這是什麼複雜寫程式的技術或者高深的專業知識。但實際上設計模式是一種能讓我們能夠寫出更好、更
      
    
    </summary>
    
      <category term="C/C++教學" scheme="https://shengyu7697.github.io/categories/C-C-%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="C/C++" scheme="https://shengyu7697.github.io/tags/C-C/"/>
    
      <category term="設計模型" scheme="https://shengyu7697.github.io/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
